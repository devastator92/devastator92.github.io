<html>
<!-- Mirrored from nnc3.com/mags/Networking2/tcp/ch12_02.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:33 GMT -->
<head><title>User Authentication  (TCP/IP Network Administration, 3rd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Craig Hunt" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596002971L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="TCP/IP Network Administration, 3rd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.html" alt="TCP/IP Network Administration" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.html" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_01.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch12_03.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table></div>



<h2 class="sect1">12.2. User Authentication </h2>

<p>Good passwords <a name="INDEX-2646" />
<a name="INDEX-2647" /><a name="INDEX-2648" />are one
<a name="INDEX-2649" />of the simplest parts of good
network security. Passwords are used to log into systems that use
password authentication. Popular mythology says that all network
security breaches are caused by sophisticated crackers who discover
software security holes. In reality, some of the most famous
intruders entered systems simply by guessing or stealing passwords or
by exploiting well-known security problems in outdated software.
Later in this chapter, we look at guidelines for keeping software up
to date and ways to prevent a thief from stealing your password.
First, let's see what we can do to prevent it from being
guessed.
</p>

<p>These are a few things that make it easy to guess passwords:</p>

<ul><li>
<p>Accounts that use the account name as the password. Accounts with
this type of trivial password are called <em class="emphasis">joe
accounts</em>.
</p>
</li><li>
<p>Guest or demonstration accounts that require no password or use a
well-publicized password.
</p>
</li><li>
<p>System accounts with default passwords.</p>
</li><li>
<p>User who tell their passwords to others.</p>
</li></ul>
<p>Guessing these kinds of passwords requires no skill, just lots of
spare time! Changing your password frequently is a deterrent to
password guessing. However, if you choose good passwords, don't
change them so often that it is hard to remember them. Many security
experts recommend that passwords should be changed about every 3 to 6
months.
</p>

<p>A more sophisticated form of password guessing is
<em class="emphasis">dictionary guessing</em>. Dictionary guessing uses a
program that encrypts each word in a dictionary (e.g.,
<em class="emphasis">/usr/dict/words</em>) and compares each encrypted
word to the encrypted password in the
<em class="emphasis">/etc/passwd</em> file. Dictionary guessing is not
limited to words from a dictionary. Things known about you (your
name, initials, telephone number, etc.) are also run through the
guessing program. Because of dictionary guessing, you must protect
the <em class="emphasis">/etc/passwd</em> file.
</p>

<p>Some systems provide a <em class="emphasis">shadow password file</em> to
hide the encrypted passwords from potential intruders. If your system
has a shadow password facility, use it. Hiding encrypted passwords
greatly reduces the risk of password guessing.
</p>

<a name="tcp3-CHP-12-SECT-2.1" /><div class="sect2">
<h3 class="sect2">12.2.1. The Shadow Password File </h3>

<p>Shadow <a name="INDEX-2650" /> <a name="INDEX-2651" /> <a name="INDEX-2652" /> <a name="INDEX-2653" />password files have restricted permissions
that prevent them from being read by intruders. The encrypted
password is stored only in the shadow password file,
<em class="emphasis">/etc/shadow</em>, and not in the
<em class="emphasis">/etc/passwd</em> file. The
<em class="emphasis">passwd</em> file is maintained as a world-readable
file because it contains information that various programs use. The
<em class="emphasis">shadow</em> file can be read only by root and it does
not duplicate the information in the <em class="emphasis">passwd</em>
file. It contains only passwords and the information needed to manage
them. The format of a <em class="emphasis">shadow</em> file entry on a
<a name="INDEX-2654" />Solaris system is:
</p>

<blockquote><pre class="code"><em class="replaceable">username:password:lastchg:min:max:warn:inactive:expire:flag</em></pre></blockquote>

<p><em class="replaceable">username</em> is the login username.
<em class="replaceable">password</em> is the encrypted password or, on
Solaris systems, one of the keyword values <tt class="literal">NP</tt> or
<tt class="literal">*LK*</tt>. <em class="replaceable">lastchg</em> is the
date that the password was last changed, written as the number of
days from January 1, 1970 to the date of the change.
<em class="replaceable">min</em> is the minimum number of days that
must elapse before the password can be changed.
<em class="replaceable">max</em> is the maximum number of days the user
can keep the password before it must be changed.
<em class="replaceable">warn</em> is the number of days before the
password expires that the user is warned.
<em class="replaceable">inactive</em> is the number of days the account
can be inactive before it is locked.
<em class="replaceable">expire</em> is the date on which the account
will be closed. <em class="replaceable">flag</em> is unused.
</p>

<p>The encrypted password appears only in this file. Every password
field in the <em class="emphasis">/etc/passwd</em> file contains an
<tt class="literal">x</tt>, which tells the system to look in the
<em class="emphasis">shadow</em> file for the real password. Every
password field in the <em class="emphasis">/etc/shadow</em> file contains
either an encrypted password, <tt class="literal">NP</tt>, or
<tt class="literal">*LK*</tt>. If it contains the keyword
<tt class="literal">NP</tt>, it means that there is no password because
this is not a login account. System accounts, such as
<em class="emphasis">daemon</em> or <em class="emphasis">uucp</em>, are not
login accounts, so they have <tt class="literal">NP</tt> in the password
field. <tt class="literal">*LK*</tt> in the password field means that this
account has been locked and is therefore disabled from any further
use. Other systems use different symbols in the password field to
indicate these conditions; some Linux systems use
<tt class="literal">*</tt> and <tt class="literal">!!</tt>. However, all systems
have some technique for differentiating active login accounts from
other types of user IDs.
</p>

<p>While the most important purpose of the <em class="emphasis">shadow</em>
file is to protect the password, the additional fields in the shadow
entry provide other useful security services. One of these is
<em class="emphasis">password aging</em>. A password
<a name="INDEX-2655" />aging
mechanism defines a lifetime for each password. When a password
reaches the end of its lifetime, the password aging mechanism
notifies the user to change the password. If it is not changed within
some specified period, the password is removed from the system and
the user is blocked from using his account.
</p>

<p>The lastchg, max, and warn fields all play a role in password aging.
They allow the system to know when the password was changed and how
long it should be kept, as well as when the user should be warned
about his impending doom. Another nice feature of the shadow file is
the min field. This is a more subtle aspect of password aging. It
prevents the user from changing her favorite password to a dummy
password and then immediately back to the favorite. When the password
is changed it must be used for the number of days defined by min
before it can be changed again. This reduces one of the common tricks
used to avoid really changing passwords.
</p>

<p>The inactive and expire fields help eliminate unused accounts. Here,
"inactivity" is determined by the number of days the
account continues with an expired password. Once the password
expires, the user is given some number of days to log in and set a
new password. If the user does not log in before the specified number
of days has elapsed, the account is locked and the user cannot log
in.
</p>

<p>The expire field lets you create a user account that has a specified
"life." When the date stored in the expire field is
reached, the user account is disabled even if it is still active. The
expiration date is stored as the number of days since January 1,
1970. 
</p>

<p>On a Solaris system the <em class="emphasis">/etc/shadow</em> file is not
edited directly. It is modified through the Users window of the
<tt class="literal">admintool</tt> or special options on the
<tt class="literal">passwd</tt> command line. This window is shown in <a href="ch12_02.html#tcp3-CHP-12-FIG-1">Figure 12-1</a>. The username, password, min, max, warn,
inactive, and expire fields are clearly shown.
</p>

<a name="tcp3-CHP-12-FIG-1" /><div class="figure"><img height="457" alt="Figure 12-1" src="figs/tcp3_1201.gif" width="311" /></div><h4 class="objtitle">Figure 12-1. Admintool password maintenance</h4>

<p>The <tt class="literal">passwd</tt><a name="INDEX-2656" /> command on Solaris systems has
<tt class="literal">-n</tt> <em class="replaceable">min</em>, <tt class="literal">-w</tt>
<em class="replaceable">warn</em>, and <tt class="literal">-x</tt>
<em class="replaceable">max</em> options to set the min, max,
and warn fields in the <em class="emphasis">/etc/shadow</em> file. Only
the root user can invoke these options. Here, root sets the maximum
life of Tyler's password to 180 days:
</p>

<blockquote><pre class="code"># <b class="emphasis-bold">passwd -x 180 tyler</b></pre></blockquote>

<p>The Solaris system permits the system administrator to set default
values for all of these options so that they do not have to be set
every time a user is added through the <tt class="literal">admintool</tt>
or the <tt class="literal">passwd</tt> command line. The default values are
set in the
<em class="emphasis">/etc/default/passwd</em><a name="INDEX-2657" /> file.
</p>

<blockquote><pre class="code">% <b class="emphasis-bold">cat /etc/default/passwd</b> 
#ident  "@(#)passwd.dfl 1.3     92/07/14 SMI" 
AXWEEKS= 
INWEEKS=
PASSLENGTH=6</pre></blockquote>

<p>The default values that can be set in the
<em class="emphasis">/etc/default/passwd</em> file are:
</p>

<dl>
<a name="INDEX-2658" /><dt><b><tt class="literal">MAXWEEKS</tt></b></dt>
<dd>
<p>The maximum life of a password defined in weeks, not days. The
180-day period used in the example above would be defined with this
parameter as <tt class="literal">MAXWEEKS=26</tt>.
</p>
</dd>


<a name="INDEX-2659" /><dt><b><tt class="literal">MINWEEKS</tt></b></dt>
<dd>
<p>The minimum number of weeks a password must be used before it can be
changed.
</p>
</dd>


<a name="INDEX-2660" /><dt><b><tt class="literal">PASSLENGTH</tt></b></dt>
<dd>
<p>The minimum number of characters that a password must contain. This
is set to 6 in the sample file. Only the first eight characters are
significant on a Solaris system; setting the value above 8 does not
change that fact.
</p>
</dd>


<a name="INDEX-2661" /><dt><b><tt class="literal">WARNWEEKS</tt></b></dt>
<dd>
<p>The number of weeks before a password expires that the user is warned.</p>
</dd>

</dl>

<p>This section uses Solaris as an example. The shadow password system
is provided as part of the Solaris operating system. It is also
included with Linux systems. The <em class="emphasis">shadow</em> file
described here is exactly the same format as used on Linux systems,
and it functions in the same way.
</p>

<p>It is very difficult to take the encrypted password and decrypt it
back to its original form, but encrypted passwords can be compared
against encrypted dictionaries. If bad passwords are used, they can
be easily guessed. Take care to protect the
<em class="emphasis">/etc/passwd</em> file and choose good <a name="INDEX-2662" /> <a name="INDEX-2663" /> <a name="INDEX-2664" /> <a name="INDEX-2665" />passwords.
</p>

</div>
<a name="tcp3-CHP-12-SECT-2.2" /><div class="sect2">
<h3 class="sect2">12.2.2. Choosing a Password </h3>

<p>A good
<a name="INDEX-2666" />
<a name="INDEX-2667" />password
is an essential part of security. We usually think of the password
used for a traditional login; however, passwords, passphrases, and
keys are also needed for more advanced authentication systems. For
all of these purposes, you want to choose a good password. Choosing a
good password boils down to not choosing a password that can be
guessed using the techniques described above. Some guidelines for
choosing a good password are:
</p>

<ul><li>
<p>Don't use your login name.</p>
</li><li>
<p>Don't use the name of anyone or anything.</p>
</li><li>
<p>Don't use any English or foreign-language word or abbreviation.</p>
</li><li>
<p>Don't use any personal information associated with the owner of
the account. For example, don't use your initials, phone
number, social security number, job title, organizational unit, etc.
</p>
</li><li>
<p>Don't use keyboard sequences, e.g., qwerty.</p>
</li><li>
<p>Don't use any of the above spelled backwards, or in caps, or
otherwise disguised.
</p>
</li><li>
<p>Don't use an all-numeric password.</p>
</li><li>
<p>Don't use a sample password, no matter how good, that
you've gotten from a book that discusses computer security.
</p>
</li><li>
<p><em class="emphasis">Do</em> use a mixture of numbers, special characters,
and mixed-case letters.
</p>
</li><li>
<p><em class="emphasis">Do</em> use at least six characters.</p>
</li><li>
<p><em class="emphasis">Do</em> use a seemingly random selection of letters
and numbers.
</p>
</li></ul>
<p>Common suggestions for constructing seemingly random passwords are:</p>

<ul><li>
<p>Use the first letter of each word from a line in a book, song, or
poem. For example, "People don't know you and trust is a
joke."<a href="#FOOTNOTE-130">[130]</a> would produce
Pd'ky&amp;tiaj.
</p><blockquote class="footnote"> <a name="FOOTNOTE-130" /><p>[130]Toad the Wet Sprocket, "Walk on
the Ocean."</p> </blockquote>
</li><li>
<p>Use the output from a random password generator. Select a random
string that can be pronounced and is easy to remember. For example,
the random string "adazac" can be pronounced a-da-zac,
and you can remember it by thinking of it as "A-to-Z."
Add uppercase letters to create your own emphasis, e.g.,
aDAzac.<a href="#FOOTNOTE-131">[131]</a>
</p><blockquote class="footnote"> <a name="FOOTNOTE-131" /><p>[131]A password generator created this
password.</p> </blockquote>
</li><li>
<p>Use two short words connected by punctuation, e.g., wRen%Rug.</p>
</li><li>
<p>Use numbers and letters to create an imaginary vanity license plate
password, e.g., 2hot4U?.
</p>
</li></ul>
<p>A common theme of these suggestions is that the password should be
easy to remember. Avoid passwords that must be written down to be
remembered. If unreliable people gain access to your office and find
the password you have written down, the security of your system will
be compromised.
</p>

<p>However, don't assume that you can't remember a random
password. It may be difficult the first few times you use the
password, but any password that is used often enough is easy to
remember. If you have an account on a system that you rarely use, you
may have trouble remembering a random password. But in that case, the
best solution is to get rid of the account. Unused and underutilized
accounts are prime targets for intruders. They like to attack unused
accounts because there is no user to notice changes to the files or
strange <em class="emphasis">Last login:</em> messages. Remove all unused
accounts from your systems.
</p>

<p>How do you ensure that the guidance for creating new passwords is
followed? The most important step is to make sure that every user
knows these suggestions and the importance of following them. Cover
this topic in your network security plan, and periodically reinforce
it through newsletter articles and online system bulletins.
</p>

<p>It is also possible to use programs that force users to follow
specific password selection guidelines. The web
<a name="INDEX-2668" />page
<a href="http://csrc.nist.gov/tools/tools.htm">http://csrc.nist.gov/tools/tools.htm</a> lists
several programs that do exactly that.
</p>

</div>
<a name="tcp3-CHP-12-SECT-2.3" /><div class="sect2">
<h3 class="sect2">12.2.3. One-Time Passwords </h3>

<p>Sometimes good
<a name="INDEX-2669" />
<a name="INDEX-2670" />
<a name="INDEX-2671" />passwords
are not enough. Passwords are transmitted across the network as clear
text. Intruders can use protocol-analyzer software to spy on network
traffic and steal passwords. If a thief steals your password, it does
not matter how good the password was.
</p>

<p>The thief can be on any network that handles your TCP/IP packets. If
you log in through your local network, you have to worry only about
local snoops. But if you log in over the Internet, you must worry
about unseen listeners from any number of unknown networks.
</p>

<p>Commands that use encrypted passwords are not vulnerable to this type
of attack. Because of this, <tt class="literal">telnet</tt> has been
largely supplanted by secure shell (<tt class="literal">ssh</tt>). However,
the secure shell client may not be available at a remote site. Use
one-time passwords for remote logins when you cannot use secure
shell. Because a one-time password can be used only once, a thief who
steals the password cannot use it.
</p>

<p>Naturally, one-time password systems are a hassle. You must carry
with you a list of one-time passwords, or something that can generate
them, any time you want to log in. If you forget the password list,
you cannot log in. However, this may not be as big a problem as it
seems. You usually log in from your office where your primary login
host is probably on your desktop or your local area network. When you
log into your desktop system from its keyboard, the password does not
traverse the network, so you can use a reusable password. And
<tt class="literal">ssh</tt> can be used any time you control both ends of
the connection, for example, when logging in with your laptop.
One-time passwords are needed only for the occasions when you log in
from a remote location that does not offer <tt class="literal">ssh</tt>.
For this reason, some one-time password systems are designed to allow
reusable passwords when they are appropriate.
</p>

<p>There are several one-time password systems. Some use specialized
hardware such as "smart cards." OPIE is a free software
system that requires no special hardware.
</p>

</div>
<a name="tcp3-CHP-12-SECT-2.4" /><div class="sect2">
<h3 class="sect2">12.2.4. OPIE </h3>

<p><em class="emphasis">One-time Passwords In Everything</em> (OPIE) is
<a name="INDEX-2672" />
<a name="INDEX-2673" />
<a name="INDEX-2674" /> <a name="INDEX-2675" />free software
from the U.S. Naval Research Laboratory (NRL) that modifies a Unix
system to use one-time passwords. OPIE is directly derived from Skey,
which is a one-time password system created by Bell Communications
Research (Bellcore).
</p>

<p>Download OPIE from the Internet from
<a name="INDEX-2676" /><a href="http://inner.net/opie">http://inner.net/opie</a>. The current version of
OPIE is <em class="emphasis">opie-2.4.tar.gz</em>. It is a binary file.
<tt class="literal">gunzip</tt> the file and extract it using
<tt class="literal">tar</tt>. The directory this produces contains the
source files, Makefiles, and scripts necessary to compile and install
OPIE.
</p>

<p>OPIE comes with <tt class="literal">configure</tt>, an auto-configuration
script that detects your system's configuration and modifies
the Makefile accordingly. It does a good job, but you still should
manually edit the Makefile to make sure it is correct. For example,
my Linux system uses the Washington University FTP daemon
<tt class="literal">wu.ftpd</tt>. OPIE replaces <tt class="literal">login</tt>,
<tt class="literal">su</tt>, and <tt class="literal">ftpd</tt> with its own
version of these programs. Using an earlier version of OPIE on my
Linux system, <tt class="literal">configure</tt> did not find
<tt class="literal">ftpd</tt>, and I did not notice the problem when I
checked the Makefile. <tt class="literal">make</tt> ran without errors, but
<tt class="literal">make</tt> <tt class="literal">install</tt> failed during the
install of the OPIE FTP daemon. The Makefile was easily corrected and
the rerun of <tt class="literal">make install</tt> was successful.
</p>

<p>The effects of OPIE are evident as soon as the install completes. Run
<tt class="literal">su</tt> and you're prompted with <tt class="literal">root's
response:</tt> instead of <tt class="literal">Password:</tt>.
<tt class="literal">login</tt> prompts with <tt class="literal">Response</tt>
<tt class="literal">or Password:</tt> instead of just
<tt class="literal">Password:</tt>. The <tt class="literal">response</tt>
requested by these programs is the OPIE equivalent of a password.
Programs that prompt with <tt class="literal">Response or</tt>
<tt class="literal">Password</tt> accept either the OPIE response or the
traditional password from the <em class="emphasis">/etc/passwd</em> file.
This feature permits users to migrate gracefully from traditional
passwords to OPIE. It also allows local console logins with reusable
passwords while permitting remote logins with one-time passwords. The
best of both worlds -- convenient local logins without creating
separate local and remote login accounts!
</p>

<p>To use OPIE you must first select a secret password that is used to
generate the one-time password list, and then run the program that
generates the list. To select a secret password, run
<tt class="literal">opiepasswd</tt> as shown:
</p>

<blockquote><pre class="code">$ <b class="emphasis-bold">opiepasswd -c</b> 
Updating kristin: 
Reminder  -  Only use this method from the console; NEVER from remote. 
 If you are using telnet, xterm, or a dial-in, type ^C now or exit with 
 no password. Then run opiepasswd without the -c parameter. 
Using MD5 to compute responses. 
Enter old secret pass phrase: <b class="emphasis-bold">3J5Wd6PaWP</b> 
Enter new secret pass phrase: <b class="emphasis-bold">9WA11WSfW95/NT</b>
Again new secret pass phrase: <b class="emphasis-bold">9WA11WSfW95/NT</b></pre></blockquote>

<p>This example shows the user <em class="emphasis">kristin</em> updating her
secret password. She runs <tt class="literal">opiepasswd</tt> from the
computer's console, as indicated by the <tt class="literal">-c</tt>
command option. Running <tt class="literal">opiepasswd</tt> from the
console is the most secure. If it is not run from the console, you
must have a copy of the <tt class="literal">opiekey</tt> software with you
to generate the correct responses needed to enter your old and new
secret passwords, because clear text passwords are accepted only from
the console. Kristin is prompted to enter her old password and to
select a new one. OPIE passwords must be at least 10 characters long.
Since the new password is long enough, <tt class="literal">opiepasswd</tt>
accepts it and displays the following two lines:
</p>

<blockquote><pre class="code">ID kristin OPIE key is 499 be93564
CITE JAN GORY BELA GET ABED</pre></blockquote>

<p>These lines tell Kristin the information she needs to generate OPIE
login responses and the first response she will need to log into the
system. The one-time password needed for Kristin's next login
response is the second line of this display: a group of six short,
uppercase character strings. The first line of the display contains
the initial sequence number (499) and the seed (be93564) she needs,
along with her secret password, to generate OPIE login responses. The
software used to generate those responses is
<tt class="literal">opiekey</tt>.
</p>

<p><tt class="literal">opiekey</tt> takes the login sequence number, the
user's seed, and the user's secret password as input and
outputs the correct one-time password. If you have
<tt class="literal">opiekey</tt> software on the system from which you are
initiating the login, you can produce one-time passwords one at a
time. If, however, you will not have access to
<tt class="literal">opiekey</tt> when you are away from your login host,
you can use the <tt class="literal">-n</tt> option to request several
passwords. Write the passwords down, put them in your wallet, and
you're ready to go! <a href="#FOOTNOTE-132">[132]</a></p><blockquote class="footnote"> <a name="FOOTNOTE-132" /><p>[132]Security experts will
cringe when they read this suggestion. Writing down passwords is a
"no-no." Frankly, I think the people who steal wallets
are more interested in my money and credit cards than in the password
to my system. But you should consider this suggestion in light of the
level of protection your system needs.</p> </blockquote>

<p>In the
following example we request five (<tt class="literal">-n 5</tt>) responses
from <tt class="literal">opiekey</tt>:
</p>

<blockquote><pre class="code"><b class="emphasis-bold">$ opiekey -n 5 495 wi01309</b> 
Using MD5 algorithm to compute response. 
Reminder: Don't use  opiekey  from  telnet  or dial-in sessions. 
Enter secret pass phrase: <b class="emphasis-bold">UUaX26CPaU</b> 
491: HOST VET FOWL SEEK IOWA YAP 
492: JOB ARTS WERE FEAT TILE IBIS 
493: TRUE BRED JOEL USER HALT EBEN 
494: HOOD WED MOLT PAN FED RUBY
495: SUB YAW BILE GLEE OWE NOR</pre></blockquote>

<p>First <tt class="literal">opiekey</tt> tells us that it is using the MD5
algorithm to produce the responses, which is the default for OPIE.
For compatibility with older Skey or OPIE implementations, force
<tt class="literal">opiekey</tt> to use the MD4 algorithm by using the
<tt class="literal">-4</tt> command-line option. <tt class="literal">opiekey</tt>
prompts for your secret password. This is the password you defined
with the <tt class="literal">opiepasswd</tt> command. It then prints out
the number of responses requested and lists them in sequence number
order. The login sequence numbers in the example are 495 to 491. When
the sequence number gets down to 10, rerun
<tt class="literal">opiepasswd</tt> and select a new secret password.
Selecting a new secret password resets the sequence number to 499.
</p>

<p>The OPIE login prompt displays a sequence number, and you must
provide the response that goes with that sequence number. For
example:
</p>

<blockquote><pre class="code">login: <b class="emphasis-bold">tyler</b> 
otp-md5 492 wi01309 Response or Password:
<b class="emphasis-bold">JOB ARTS WERE FEAT TILE IBIS</b></pre></blockquote>

<p>At the <tt class="literal">login:</tt> prompt, Tyler enters her username.
The system then displays a single line that tells her that one-time
passwords are being generated with the MD5 algorithm (otp-md5), that
this is login sequence number 492, and that the seed used for her
one-time passwords is wi01309. She looks up the response for login
number 492 and enters the six short strings. She then marks that
response off her list because it cannot be used again to log into the
system. A response from the list must be used any time she is not
sitting at the console of her system. Reusable passwords can be used
only at the console.
</p>

<p>Secure shell is used for remote logins whenever it is available on
the client. Because of this, one-time passwords are needed only in
special cases. Generally, it is sufficient to have one small OPIE
server on your network. Remote users who are forced to use one-time
passwords log into that server and then use a preferred mechanism,
such as <tt class="literal">ssh</tt>, to log into your real <a name="INDEX-2677" /> <a name="INDEX-2678" /> <a name="INDEX-2679" /> <a name="INDEX-2680" />servers.
</p>

</div>
<a name="tcp3-CHP-12-SECT-2.5" /><div class="sect2">
<h3 class="sect2">12.2.5. Secure the r Commands </h3>

<p>Some <a name="INDEX-2681" /> <a name="INDEX-2682" /> <a name="INDEX-2683" />applications use their own
security mechanisms. Make sure that the security for these
applications is configured properly. In particular, check the Unix
<tt class="literal">r</tt> commands, which are a set of Unix networking
applications comparable to <tt class="literal">ftp</tt> and
<tt class="literal">telnet</tt>. Care must be taken to ensure that the
<tt class="literal">r</tt> commands don't compromise system security.
Improperly configured <tt class="literal">r</tt> commands can open access
to your computer facilities to virtually everyone in the world. For
this reason, use of the <tt class="literal">r</tt> commands is discouraged.
</p>

<p>In place of password authentication, the <tt class="literal">r</tt>
commands use a security system based on trusted hosts and users.
Trusted users on <a name="INDEX-2684" />
<a name="INDEX-2685" />
<a name="INDEX-2686" />trusted hosts are allowed to access the
local system without providing a password. Trusted hosts are also
called "<a name="INDEX-2687" />equivalent hosts" because the system
assumes that users given access to a trusted host should be given
equivalent access to the local host. The system assumes that user
accounts with the same name on both hosts are "owned" by
the same user. For example, a user logged in as
<em class="emphasis">becky</em> on a trusted system is granted the same
access as the user logged in as <em class="emphasis">becky</em> on the
local system.
</p>

<p>This authentication system requires
<a name="INDEX-2688" />databases that define the trusted
hosts and the trusted users. The databases used to configure the
<tt class="literal">r</tt> commands are
<em class="emphasis">/etc/hosts.equiv</em><a name="INDEX-2689" /> and
<em class="emphasis">.rhosts</em>.
</p>

<p>The <em class="emphasis">/etc/hosts.equiv</em> file defines the hosts and
users that are granted "trusted" <tt class="literal">r</tt>
command access to your system. This file can also define hosts and
users that are explicitly denied trusted access. Not having trusted
access doesn't mean that the user is denied access; it just
means that he is required to supply a password.
</p>

<p>The basic format of entries in the
<em class="emphasis">/etc/hosts.equiv</em> file is:
</p>

<blockquote><pre class="code"> [+ | -][<em class="emphasis">hostname</em>] [+ | -][<em class="emphasis">username</em>]</pre></blockquote>

<p>The <em class="replaceable">hostname</em> is the name of a
"trusted" host, which may optionally be preceded by a
plus sign (+). The plus sign has no real significance, except when
used alone. A plus sign without a hostname following it is a wildcard
character that means "any host."
</p>

<p>If a host is granted equivalence, users logged into that host are
allowed access to like-named user accounts on your system without
providing a password. (This is one reason for administrators to
observe uniform rules in handing out login names.) The optional
<em class="replaceable">username</em> is the name of a user on the
trusted host who is granted access to all user accounts. If
<em class="replaceable">username</em> is specified, that user is not
limited to like-named accounts, but is given access to all user
accounts without being required to provide a password.<a href="#FOOTNOTE-133">[133]</a>
</p><blockquote class="footnote">
<a name="FOOTNOTE-133" /><p>[133]The <em class="emphasis">root</em> account is not included.</p>
</blockquote>

<p>The <em class="replaceable">hostname</em> may also be preceded by a
minus sign (-). This explicitly says that the host is
<em class="emphasis">not</em> an equivalent system. Users from that host
must always supply a password when they use an <tt class="literal">r</tt>
command to interact with your system. A
<em class="replaceable">username</em> can also be preceded by a minus
sign. This says that, whatever else may be true about that host, the
user is not trusted and must always supply a password.
</p>

<p>The following examples show how entries in the
<em class="emphasis">hosts.equiv</em> file are interpreted:
</p>

<dl>
<dt><b><tt class="literal">rodent</tt></b></dt>
<dd>
<p>Allows password-free access from any user on
<em class="emphasis">rodent</em> to a like-named user account on your
local system.
</p>
</dd>


<dt><b><tt class="literal">-rodent</tt></b></dt>
<dd>
<p>Denies password-free access from any user on
<em class="emphasis">rodent</em> to accounts on your system.
</p>
</dd>


<dt><b><tt class="literal">rodent -david</tt></b></dt>
<dd>
<p>Denies password-free access to the user <em class="emphasis">david</em> if
he attempts to access your system from <em class="emphasis">rodent</em>.
</p>
</dd>


<dt><b><tt class="literal">rodent +becky</tt></b></dt>
<dd>
<p>Allows the user <em class="emphasis">becky</em> to access any account
(except <em class="emphasis">root</em>) on your system, without supplying
a password, if she logs in from <em class="emphasis">rodent</em>.
</p>
</dd>


<dt><b><tt class="literal">+ becky</tt></b></dt>
<dd>
<p>Allows the user <em class="emphasis">becky</em> to access any account
(except <em class="emphasis">root</em>) on your system without supplying a
password, no matter what host she logs in from.
</p>
</dd>

</dl>

<p>This last entry is an example of something that should never be used
in your configuration. Don't use a standalone plus sign in
place of a hostname. It allows access from any host anywhere and can
open up a big security hole. For example, if the entry shown above
was in your <em class="emphasis">hosts.equiv</em> file, an intruder could
create an account named <em class="emphasis">becky</em> on his system and
gain access to every account on your system. Check
<em class="emphasis">/etc/hosts.equiv,</em>
<em class="emphasis">~/.rhosts</em>, and
<em class="emphasis">/etc/hosts.lpd</em> to make sure that none of them
contains a + entry. Remember to check the
<em class="emphasis">.rhosts</em> file in every user's home
directory.
</p>

<p>A simple typographical error could give you a standalone plus sign.
For example, consider the entry:
</p>

<blockquote><pre class="code"> <tt class="userinput"><b>+ rodent becky</b></tt></pre></blockquote>

<p>The system administrator probably meant "give
<em class="emphasis">becky</em> password-free access to all accounts when
she logs in from <em class="emphasis">rodent</em>." However, with an
extraneous space after the + sign, it means "allow users named
<em class="emphasis">rodent</em> and <em class="emphasis">becky</em>
password-free access from any host in the world." Don't
use a plus sign in front of a hostname, and always use care when
working with the <em class="emphasis">/etc/hosts.equiv</em> file to avoid
security problems.
</p>

<p>When configuring the <em class="emphasis">/etc/hosts.equiv</em> file,
grant trusted access only to the systems and users you actually
trust. Don't grant trusted access to every system attached to
your local network. In fact, it is best not to use the
<tt class="literal">r</tt> commands at all. If you must use them, only
trust hosts from your local network when you know the person
responsible for that host, when you know that the host is not
available for public use, and when the local network is protected by
a firewall. Don't grant trusted access by default -- have
some reason for conferring trusted status. Never grant trust to
remotely located systems. It is too easy for an intruder to corrupt
routing or DNS in order to fool your system when you grant trust to a
remote system. Also, never begin your
<em class="emphasis">hosts.equiv</em> file with a minus sign as the first
character. This confuses some systems, causing them to improperly
grant access. Always err on the side of caution when creating a
<em class="emphasis">hosts.equiv</em> file. Adding trusted hosts as they
are requested is much easier than recovering from a malicious
intruder.
</p>

<p>The <em class="emphasis">.rhosts</em><a name="INDEX-2690" /> file grants or denies
password-free <tt class="literal">r</tt> command access to a specific
user's account. It is placed in the user's home directory
and contains entries that define the trusted hosts and users. Entries
in the <em class="emphasis">.rhosts</em> file use the same format as
entries in the <em class="emphasis">hosts.equiv</em> file and function in
almost the same way. The difference is the scope of access granted by
entries in these two files. In the <em class="emphasis">.rhosts</em> file,
the entries grant or deny access to a single user account; the
entries in <em class="emphasis">hosts.equiv</em> control access to an
entire system.
</p>

<p>This functional difference can be shown in a simple example. Assume
the following entry:
</p>

<blockquote><pre class="code">horseshoe anthony</pre></blockquote>

<p>In <em class="emphasis">crab</em>'s <em class="emphasis">hosts.equiv</em>
file, this entry means that the user <em class="emphasis">anthony</em> on
<em class="emphasis">horseshoe</em> can access any account on
<em class="emphasis">crab</em> without entering a password. In an
<em class="emphasis">.rhosts</em> file in the home directory of user
<em class="emphasis">resnick</em>, the exact same entry allows
<em class="emphasis">anthony</em> to <tt class="literal">rlogin</tt> from
<em class="emphasis">horseshoe</em> as <em class="emphasis">resnick</em>
without entering a password, but it does not grant password-free
access to any other accounts on <em class="emphasis">crab</em>.
</p>

<p>Individuals use the <em class="emphasis">.rhosts</em> file to establish
equivalence among the different accounts they own. The entry shown
above would probably be made only if <em class="emphasis">anthony</em> and
<em class="emphasis">resnick</em> are the same person. For example, I have
accounts on several different systems. Sometimes my username is
<em class="emphasis">hunt</em>, and sometimes it is
<em class="emphasis">craig</em>. It would be nice if I had the same
account name everywhere, but that is not always possible; the names
<em class="emphasis">craig</em> and <em class="emphasis">hunt</em> are used by
two other people on my local network. I want to be able to
<tt class="literal">rlogin</tt> to my workstation from any host that I have
an account on, but I don't want mistaken logins from the other
<em class="emphasis">craig</em> and the other <em class="emphasis">hunt</em>.
The <em class="emphasis">.rhosts</em> file gives me a way to control this
problem.
</p>

<p>For example, assume my username on <em class="emphasis">crab</em> is
<em class="emphasis">craig</em>, but my username on
<em class="emphasis">filbert</em> is <em class="emphasis">hunt</em>. Another
user on <em class="emphasis">filbert</em> is <em class="emphasis">craig</em>.
To allow myself password-free access to my <em class="emphasis">crab</em>
account from <em class="emphasis">filbert</em>, and to make sure that the
other user doesn't have password-free access, I put the
following <em class="emphasis">.rhosts</em> file in my home directory:
</p>

<blockquote><pre class="code">filbert hunt
filbert -craig</pre></blockquote>

<p>Normally the <em class="emphasis">hosts.equiv</em> file is searched first,
followed by the user's <em class="emphasis">.rhosts</em> file, if it
exists. The first explicit match determines whether or not
password-free access is allowed. Therefore, the
<em class="emphasis">.rhosts</em> file cannot override the
<em class="emphasis">hosts.equiv</em> file. The exception to this is root
user access. When a root user attempts to access a system via the
<tt class="literal">r</tt> commands, the <em class="emphasis">hosts.equiv</em>
file is not checked; only <em class="emphasis">.rhosts</em> in the root
user's home directory is consulted. This allows root access to
be more tightly controlled. If the <em class="emphasis">hosts.equiv</em>
file were used for root access, entries that grant trusted access to
hosts would give root users on those hosts root privileges. You can
add trusted hosts to <em class="emphasis">hosts.equiv</em> without
granting remote root users root access to your system.
</p>

<p>You should remember that the user can provide access with the
<em class="emphasis">.rhosts</em> file even when the
<em class="emphasis">hosts.equiv</em> file doesn't exist. The only
way to prevent users from doing this is to periodically check for and
remove the <em class="emphasis">.rhosts</em> files. As long as you have
the <tt class="literal">r</tt> commands on your system, it is possible for
a user to accidentally compromise the security of your <a name="INDEX-2691" /> <a name="INDEX-2692" /> <a name="INDEX-2693" />system.
</p>

</div>
<a name="tcp3-CHP-12-SECT-2.6" /><div class="sect2">
<h3 class="sect2">12.2.6. Secure Shell </h3>

<p>The weak <a name="INDEX-2694" /> <a name="INDEX-2695" />security
of the <tt class="literal">r</tt> commands poses a security threat. You
cannot use these commands to provide secure remote access, even if
you use all the techniques given in the previous section. At best,
only trusted local systems on a secured local network can be given
access via the <tt class="literal">r</tt> commands. The reason for this is
that the <tt class="literal">r</tt> commands grant trust based on a belief
that the IP address uniquely identifies the correct computer.
Normally it does. But an intruder can corrupt DNS to provide the
wrong IP address or corrupt routing to deliver to the wrong network,
thus undermining the authentication scheme used by the
<tt class="literal">r</tt> commands.
</p>

<p>An alternative to the remote shell is the <em class="emphasis">secure
shell</em>. Secure shell replaces the standard
<tt class="literal">r</tt> commands with secure commands that include
encryption and authentication. Secure shell uses a strong
authentication scheme to ensure that the trusted host really is the
host it claims to be. Secure shell provides a number of public-key
encryption schemes to ensure that every packet in the stream of
packets is from the source it claims to be from. Secure shell is
secure and easy to use.
</p>

<p>There are currently two versions of secure shell in widespread use:
SSH Secure Shell, which is a commercial product, and OpenSSH, which
is an open source product. OpenSSH is included with various versions
of Unix and Linux, and both the open source and the commercial secure
shell products are available for download from the Internet if your
system does not include secure shell. The examples used in this
section are based on OpenSSH, but the basic functions of both
versions of secure shell are essentially the same.
</p>

<p>The basic components of secure shell are:</p>

<dl>
<a name="INDEX-2696" /><dt><b><tt class="literal">sshd</tt></b></dt>
<dd>
<p>The secure shell daemon handles incoming SSH connections.
<tt class="literal">sshd</tt> should be started at boot time from one of
the boot scripts; don't start it from
<em class="emphasis">inetd.conf</em>. <tt class="literal">sshd</tt> generates an
encryption key every time it starts. This can cause it to be slow to
start, which makes it unsuitable for <em class="emphasis">inetd.conf</em>.
A system serving SSH connections must run <tt class="literal">sshd</tt>.
</p>
</dd>


<dt><b><tt class="literal">ssh</tt></b></dt>
<dd>
<p>The secure shell user command. The <tt class="literal">ssh</tt> command
replaces <tt class="literal">rsh</tt> and <tt class="literal">rlogin</tt>. It is
used to securely pass a command to a remote system or to securely log
into a remote system. This command creates the outgoing connections
that are handled by the remote secure shell daemon. A client system
that wants to use an SSH connection must have the
<tt class="literal">ssh</tt> command.
</p>
</dd>


<a name="INDEX-2697" /><dt><b><tt class="literal">scp</tt></b></dt>
<dd>
<p>Secure copy (<tt class="literal">scp</tt>) is the secure shell version of
<tt class="literal">rcp</tt>.
</p>
</dd>


<a name="INDEX-2698" /><dt><b><tt class="literal">ssh-keygen</tt></b></dt>
<dd>
<p>Generates the public and private encryption keys used to secure the
transmission for the secure shell.
</p>
</dd>


<a name="INDEX-2699" /><dt><b><tt class="literal">sftp</tt></b></dt>
<dd>
<p>A version of FTP that operates over a secure shell connection.</p>
</dd>

</dl>

<p>When an ssh client connects to an sshd server, they exchange
<a name="INDEX-2700" />public
keys. The systems compare the keys they receive to the known keys
they have stored in the <em class="emphasis">/etc/ssh_known_hosts</em>
file and in the <em class="emphasis">.ssh/known_hosts</em> file in the
user's home directory.<a href="#FOOTNOTE-134">[134]</a></p><blockquote class="footnote"> <a name="FOOTNOTE-134" /><p>[134]The system administrator
can initialize the <em class="emphasis">ssh_known_hosts</em> file by
running <tt class="literal">make-ssh-known-hosts</tt>, which gets the key
from every host within a selected domain.</p> </blockquote> 

<p>If the
key is not found or has changed, the user is asked to verify that the
new key should be accepted:
</p>

<blockquote><pre class="code">&gt; <b class="emphasis-bold">ssh horseshoe</b> 
Host key not found from the list of known hosts. 
Are you sure you want to continue connecting (yes/no)? yes 
Host 'horseshoe' added to the list of known hosts. 
craig's password: Watts.Watt. 
Last login: Thu Sep 25 15:01:32 1997 from rodent 
Linux 2.0.0.
/usr/X11/bin/xauth:  creating new authority file /home/craig/.Xauthority</pre></blockquote>

<p>If the key is found in one of the files or is accepted by the user,
the client uses it to encrypt a randomly generated session key. The
session key is then sent to the server, and both systems use the key
to encrypt the remainder of the SSH session.
</p>

<p>The client is authenticated if it is
<a name="INDEX-2701" />
<a name="INDEX-2702" />listed
in the <em class="emphasis">hosts.equiv</em> file, the
<em class="emphasis">shost.equiv</em> file, the user's
<em class="emphasis">.rhosts</em> file, or the
<em class="emphasis">.shosts</em> file. This type of authentication is
similar to the type used by the <tt class="literal">r</tt> commands, and
the format of the <em class="emphasis">shost.equiv</em> and the
<em class="emphasis">.shosts</em> files is the same as their
<tt class="literal">r</tt> command equivalents. Notice that in the sample
above, the user is prompted for a password. If the client is not
listed in one of the files, password authentication is used. As you
can see, the password appears in plain text. However, there is no
need to worry about password thieves because SSH encrypts the
password before it is sent across the link.
</p>

<p>Users can employ a public-key challenge/response protocol for
authentication. First generate your public and private encryption
keys:
</p>

<blockquote><pre class="code">&gt; <b class="emphasis-bold">ssh-keygen</b> 
Initializing random number generator... 
Generating p:  ......................................++ (distance 616) 
Generating q:  ....................++ (distance 244) 
Computing the keys... 
Testing the keys... 
Key generation complete. 
Enter file in which to save the key (/home/craig/.ssh/identity):  
Enter passphrase: Pdky&amp;tiaj. 
Enter the same passphrase again: Pdky&amp;tiaj. 
Your identification has been saved in /home/craig/.ssh/identity. 
Your public key is: 
1024 35 158564823484025855320901702005057103023948197170850159592181522 
craig@horseshoe
Your public key has been saved in /home/craig/.ssh/identity.pub</pre></blockquote>

<p>The <tt class="literal">ssh-keygen</tt> command creates your keys. Enter a
password (or "passphrase") of at least 10 characters. Use
the rules described earlier for picking a good password to choose a
good passphrase that is easy to remember. If you forget the
passphrase, no one will be able to recover it for you.
</p>

<p>Once you have created your keys on the client system, copy the public
key to your account on the server. The public key is stored in your
home directory on the client in
<em class="emphasis">.ssh/identity.pub</em>. Copy it to
<em class="emphasis">.ssh/authorized_keys</em> in your home directory on
the server. Now when you log in using <tt class="literal">ssh</tt>, you are
prompted for the passphrase:
</p>

<blockquote><pre class="code">&gt; <b class="emphasis-bold">ssh horseshoe</b> 
Enter passphrase for RSA key 'craig@horseshoe': Pdky&amp;tiaj. 
Last login: Thu Sep 25 17:11:51 2001</pre></blockquote>

<p>To improve system security, the
<tt class="literal">r</tt><a name="INDEX-2703" />
<a name="INDEX-2704" />
<a name="INDEX-2705" /> commands
should be disabled after SSH is installed. Comment
<tt class="literal">rshd</tt>, <tt class="literal">rlogind</tt>,
<tt class="literal">rexcd</tt>, and <tt class="literal">rexd</tt> out of the
<em class="emphasis">inetd.conf</em> file to disable inbound connections
to the <tt class="literal">r</tt> commands. To ensure that SSH is used for
outbound connections, replace <tt class="literal">rlogin</tt> and
<tt class="literal">rsh</tt> with <tt class="literal">ssh</tt>. To do this, store
copies of the original <tt class="literal">rlogin</tt> and
<tt class="literal">rsh</tt> in a safe place, rerun
<tt class="literal">configure</tt> with the special options shown here, and
run <tt class="literal">make</tt> <tt class="literal">install</tt>:
</p>

<blockquote><pre class="code"># <b class="emphasis-bold">whereis rlogin</b> 
/usr/bin/rlogin 
# <b class="emphasis-bold">whereis rsh</b> 
/usr/bin/rsh 
# <b class="emphasis-bold">cp /usr/bin/rlogin /usr/lib/rlogin</b> 
# <b class="emphasis-bold">cp /usr/bin/rsh /usr/lib/rsh</b> 
# <b class="emphasis-bold">./configure  -- with-rsh=/usr/bin  -- program-transform-name='s/ s/r/'</b>
# <b class="emphasis-bold">make install</b></pre></blockquote>

<p>The example assumes that the path to the original
<tt class="literal">rlogin</tt> and <tt class="literal">rsh</tt> commands is
<em class="emphasis">/usr/bin</em>. Use whatever is correct for your
system.
</p>

<p>After replacing <tt class="literal">rlogin</tt> and <tt class="literal">rsh</tt>,
you can still log into systems that don't support SSH. You
will, however, be warned that it is not a secure connection:
</p>

<blockquote><pre class="code">&gt; <b class="emphasis-bold">rlogin cow</b> 
Secure connection to cow refused; reverting to insecure method. 
Using rsh.  WARNING: Connection will not be encrypted. 
Last login: Wed Sep 24 22:15:28 from rodent </pre></blockquote>

<p>SSH is an excellent way to have secure communications between systems
across the Internet. However, it does require that both systems have
SSH installed. When you control both ends of the link, this is not a
problem. But there are times when you must log in from a system that
is not under your control. For those occasions, one-time passwords,
such as those provided by OPIE, are still <a name="INDEX-2706" /> <a name="INDEX-2707" />essential.
</p>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_01.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch12_03.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">12. Network Security </td><td align="center" valign="top" width="228"><a href="index/index.html"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">12.3. Application Security </td></tr></table></div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><p><font size="-1"><a href="copyrght.html">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,84,90" href="../index.html" /><area shape="rect" coords="86,-7,176,90" href="../ssh/index.html" /><area shape="rect" coords="178,0,265,101" href="index.html" /><area shape="rect" coords="266,0,333,90" href="../nfs/index.html" /><area shape="rect" coords="334,-1,429,93" href="../snmp/index.html" /><area shape="rect" coords="431,0,529,116" href="../tshoot/index.html" /><area shape="rect" coords="534,0,594,104" href="../dns/index.html" /><area shape="rect" coords="595,1,704,108" href="../fire/index-2.html" /></map>

</body>
<!-- Mirrored from nnc3.com/mags/Networking2/tcp/ch12_02.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:33 GMT -->
</html>