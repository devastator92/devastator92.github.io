<html>
<!-- Mirrored from nnc3.com/mags/Networking2/nfs/ch14_06.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:42 GMT -->
<head><title>NFS server logging (Managing NFS and NIS, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Hal Stern, Mike Eisler and Ricardo Labiaga" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="1565925106L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Managing NFS and NIS, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.html" alt="Managing NFS &amp; NIS" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.html" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch14_05.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"></a></td><td align="right" valign="top" width="228"><a href="ch14_07.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table><div>



<h2 class="sect1">14.6. NFS server logging</h2>

Solaris 8 introduces the new NFS Server Logging utility. This
<a name="INDEX-2237" /> <a name="INDEX-2238" /> <a name="INDEX-2239" />utility enables the system to log file
transfer operations between an NFS server and any of its clients.
This utility was created to provide logging facilities to sites that
publish their archives via NFS within the intranet, and via
<a name="INDEX-2240" />WebNFS over the
Internet.
</p>

The NFS Server Logging utility provides the system administrator with
the tools to track file downloads and uploads, as well as directory
modification operations on NFS exported filesystems. Be careful not
to confuse this functionality with UFS Logging.<a href="#FOOTNOTE-36">[36]</a>
</p><blockquote class="footnote"> <a name="FOOTNOTE-36" />[36]UFS
logging is the process of storing transactions (changes that make up
a complete UFS operation) in a log before the transactions are
applied to the filesystem. Once a transaction is stored, it can be
later applied to the filesystem. This prevents filesystems from
becoming inconsistent, eliminating the need to run fsck.</p>
</blockquote>

The NFS Server Logging utility is not intended to serve as a
debugging tool that can be turned on to peek at filesystem traffic
during a short period of time and then be turned back off. NFS Server
Logging is most useful when it is enabled before the filesystem is
shared for the first time, and remains enabled the entire time the
filesystem is exported. It needs to run continuously in order to
monitor all NFS filesystem activity on the server, otherwise,
important path mapping information may not be obtained. This is
discussed in more detail in <a href="ch14_06.html#nfs2-CHP-14-SECT-6.5">Section 14.6.5, "Filehandle to path mapping"</a>.
</p>

This utility provides functionality different from that provided by
the public domain tools previously discussed. These tools generate
records of individual RPC transactions, whereas NFS Server Logging
generates records of conceptual file operations. Network sniffer
tools like <em class="emphasis">Ethereal</em> and
<em class="emphasis">snoop</em> report a file copy as a sequence of
distinct NFS read operations of certain length and offset performed
by the client. In contrast, the NFS Server Logging utility generates
a single record specifying the total transfer size and the duration
of the transfer. The NFS Server Logging utility reports accesses at
the conceptual level (file uploads or downloads), where network
sniffers report the details of the RPC and NFS operations.
Consequently, the logs generated by the NFS Server Logging utility
are orders of magnitude smaller and more manageable than sniffer
output. The NFS Server logs can be useful to determine the frequency
with which files in the archives are accessed or to determine what
NFS clients have accessed the files. These logs can be used to
manually or programmatically track access to objects within the
exported filesystem in the same way that FTP logs are used. As
previously pointed out, the information recorded in the NFS log is
not intended to serve as a debugging tool. The network sniffer tools
previously described are a better choice for that.
</p>

Consider the case where the server <em class="emphasis">zeus</em> exports
a filesystem with NFS logging enabled. The client
<em class="emphasis">rome</em> then copies the file
<em class="emphasis">/net/zeus/export/foo.tar.Z</em> to its local disk.
The NFS Server Logging utility records the access with a single
record of the form:
</p>

<blockquote><pre class="code">Fri Jul 28 09:27:12 2000 0 rome 136663 /export/foo.tar.Z b _ o r 32721 nfs 0 *</pre></blockquote>

This entry indicates that on Fri Jul 28 2000 at 09:27:12 in the
morning, a file was downloaded by the host <em class="emphasis">rome</em>.
The file was 136663 bytes in length and was located on the server at
/export/foo.tar.Z. The file was downloaded by userID 32721 using nfs.
The meaning of each field is explained in detail later in this
section.
</p>

In contrast, the snoop utility generates <a name="INDEX-2241" />multiple transactions:
</p>

<blockquote><pre class="code">  1   0.00000      rome -&gt; zeus      NFS C LOOKUP3 FH=0222 foo.tar.Z
  2   0.00176      zeus -&gt; rome      NFS R LOOKUP3 OK FH=EEAB
  3   0.00026      rome -&gt; zeus      NFS C ACCESS3 FH=0222 (lookup)
  4   0.00125      zeus -&gt; rome      NFS R ACCESS3 OK (lookup)
  5   0.00018      rome -&gt; zeus      NFS_ACL C GETACL3 FH=EEAB mask=10
  6   0.00139      zeus -&gt; rome      NFS_ACL R GETACL3 OK
  7   0.00026      rome -&gt; zeus      NFS C ACCESS3 FH=EEAB (read)
  8   0.00119      zeus -&gt; rome      NFS R ACCESS3 OK (read)
  9   0.00091      rome -&gt; zeus      NFS C READ3 FH=EEAB at 0 for 32768
 10   0.00020      rome -&gt; zeus      NFS C READ3 FH=EEAB at 32768 for 32768
 11   0.00399      zeus -&gt; rome      UDP IP fragment ID=56047 Offset=0    MF=1
 12   0.02736      zeus -&gt; rome      UDP IP fragment ID=56048 Offset=0    MF=1
 13   0.00009      rome -&gt; zeus      NFS C READ3 FH=EEAB at 65536 for 32768
 14   0.00020      rome -&gt; zeus      NFS C READ3 FH=EEAB at 98304 for 32768
 15   0.00017      rome -&gt; zeus      NFS C READ3 FH=EEAB at 131072 for 8192
 16   0.03482      zeus -&gt; rome      UDP IP fragment ID=56049 Offset=0    MF=1
 17   0.02740      zeus -&gt; rome      UDP IP fragment ID=56050 Offset=0    MF=1
 18   0.02739      zeus -&gt; rome      UDP IP fragment ID=56051 Offset=0    MF=1</pre></blockquote>

A single user-level copy command translates into<a name="INDEX-2242" /> multiple NFS
operations. The NFS client must first find the object via the LOOKUP3
operation, determine access rights to the object via the ACCESS3 and
GETACL3 operations and then finally read the information from the
server via multiple READ3 operations.
</p>

The NFS Server Logging mechanism was designed <a name="INDEX-2243" /> <a name="INDEX-2244" />to emulate the FTP logging
mechanism found in many FTP public domain implementations. The log
generated is specifically compatible with the log format generated by
the popular Washington University's FTP daemon (WU-ftpd).
WU-ftpd log format was chosen because of the popularity of this
particular FTP service, as well as the availability of a number of
public domain and home-grown utilities that already consume WU-ftpd
logs.
</p>

Each NFS log record contains the following <a name="INDEX-2245" /> <a name="INDEX-2246" />space-separated fields:
</p>

<dl>
<dt><i>Date</i></dt>
<dd>
The timestamp from the start of the <a name="INDEX-2247" />operation. It is represented in
local time in the form of a 26-character string. The fields are
constant width. The timestamp is formatted with ctime(3C). In the
previous example, this was Fri Jul 28 09:27:12 2000.
</p>
</dd>

</dl>

<dl>
<dt><i>ElapsedTime</i></dt>
<dd>
For reads and writes, this is the
approximate<a name="INDEX-2248" /> elapsed time from the first to last
operation. It is truncated to whole seconds. In the previous example
it is <em class="emphasis">0</em>, meaning it took less than one second.
</p>
</dd>

</dl>

<dl>
<dt><i>ClientName</i></dt>
<dd>
Name of the system accessing the object. The
name<a name="INDEX-2249" /> service switch is used on the server to
generate the client name. This means that hostnames will be printed
for those machines known within the name service. IP addresses will
be printed for hostnames that are outside the name service control.
In the previous example, this is <em class="emphasis">rome</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>TransferSize</i></dt>
<dd>
Total number of bytes read or written. It is
<a name="INDEX-2250" />always 0 for operations other than read
or write (mkdir, rmdir, etc). In the previous example, this is
136663<tt class="literal">.</tt>
</p>
</dd>

</dl>

<dl>
<dt><i>PathName</i></dt>
<dd>
Absolute pathname of the object accessed <a name="INDEX-2251" />on the server. This
pathname is always reported from the server's namespace point
of view. It is possible for the server to be unable to map NFS
filehandles to pathnames. In such a case, the NFS filehandle is
printed instead of the component name. See <a href="ch14_06.html#nfs2-CHP-14-SECT-6.5">Section 14.6.5, "Filehandle to path mapping"</a> for details. In the previous example,
the <em class="emphasis">PathName</em> is
<em class="emphasis">/export/foo</em>. The client may have mounted the
pathname on <em class="emphasis">/mnt</em> or
<em class="emphasis">/net/zeus</em>, but the pathname reported is always
the server's absolute pathname.
</p>
</dd>

</dl>

<dl>
<dt><i>DataType</i></dt>
<dd>
Indicates the type of data transfer, ASCII
transfers<a name="INDEX-2252" /> are denoted with a and binary transfers
are denoted with <em class="emphasis">b</em>. NFS transfers are always
binary; therefore, this field will always have a value of
<em class="emphasis">b</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>TransferOption</i></dt>
<dd>
Indicates any special processing performed
by<a name="INDEX-2253" /> the service. For FTP logs, it indicates
if the WU-ftpd daemon performed any kind of compression (denoted with
<em class="emphasis">C</em> ), or if the file was tarred (denoted by
<em class="emphasis">T</em> ), or if the file was uncompressed (denoted
with <em class="emphasis">U</em> ). For NFS transfers this field will
always have a value of `<em class="emphasis">_</em>', since no
special action is performed by the NFS server.
</p>
</dd>

</dl>

<dl>
<dt><i>Operation</i></dt>
<dd>
The operation performed by the server,
by<a name="INDEX-2254" /> default this is either
<em class="emphasis">i</em> for incoming (upload) or
<em class="emphasis">o</em> for outgoing (download). Note that this is
always relative to the server. If the extended log format is in use,
the operation is reported in extended format (i.e.,
<em class="emphasis">read</em>, <em class="emphasis">write</em>,
<em class="emphasis">create</em>, <em class="emphasis">setattr</em>,
<em class="emphasis">mkdir</em>, etc.). Note that this is incompatible
with the WU-ftpd log format and existing unmodified tools that
process these type of logs will not be able to process the extended
NFS log. In the previous example the client read the file, which
means it was downloaded from the server, therefore the log denotes
this with an <em class="emphasis">o</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>AccessMode</i></dt>
<dd>
Indicates the type of the user accessing
<a name="INDEX-2255" />the file. For FTP transfers, a guest user
is denoted as <em class="emphasis">g</em>, an anonymous user is denoted as
<em class="emphasis">a</em> and the real user is denoted as
<em class="emphasis">r</em>. All NFS transfers report the real user
identifier contained in the RPC; therefore, this field will alway be
<em class="emphasis">r</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>UserID</i></dt>
<dd>
User identifier (UID) used for the NFS operations.
<a name="INDEX-2256" />Note that the logging utility makes no
attempt to map the uid to the user name. Doing this could lead to
incorrect mappings when the request arrives from a different name
service domain than the one the server belongs to. Different name
service domains do not necessarily share the same user name space.
UID 32721 on the Eng domain may map to a very different user on the
Corp domain. In the previous example it is 32721.
</p>
</dd>

</dl>

<dl>
<dt><i>Service</i></dt>
<dd>
Type of service accessed by the client. The
<a name="INDEX-2257" />basic log format entry reports
<em class="emphasis">nfs</em>. The extended log format entry reports the
NFS version and protocol as well. NFS Version 3 over TCP is reported
as <em class="emphasis">nfs3-tcp</em> in the extended log format, and as
<em class="emphasis">nfs</em> in the basic log format.
</p>
</dd>

</dl>

<dl>
<dt><i>Authenticated</i></dt>
<dd>
Indicates whether the user is authenticated or not.
<a name="INDEX-2258" />A value of 0 indicates that the user is
not authenticated, or using the AUTH_SYS RPC authentication. A value
of 1 means that the user is authenticated via extended methods (such
as AUTH_DES) and the next field will include the user's
principle name. In the previous example the client is using AUTH_SYS,
therefore the field is 0.
</p>
</dd>

</dl>

<dl>
<dt><i>PrincipleName</i></dt>
<dd>
The user's principle name if authenticated; otherwise,
<a name="INDEX-2259" />the field will be `*'.
</p>
</dd>

</dl>

<a name="nfs2-CHP-14-SECT-6.1" /><div class="sect2">
<h3 class="sect2">14.6.1. NFS server logging mechanics</h3>

There are three main components involved <a name="INDEX-2260" /> <a name="INDEX-2261" />in
the logging process. First, <a name="INDEX-2262" />
<a name="INDEX-2263" />the <em class="emphasis">share</em> command
is used to enable NFS Logging on the filesystem. Second, the kernel
stores enough information about each RPC operation in a temporary
work buffer file. Third, the <em class="emphasis">nfslogd</em> daemon
processes the RPC information stored in the temporary work buffer
file, consolidates the operations into file transfer operations and
generates the final NFS log file.
</p>

<a href="ch14_06.html#nfs2-CHP-14-TABLE-2">Table 14-2</a> lists the various files involved in the
logging process, the information contained in them, who or what
program creates and modifies them and who consumes their contents.
The <em class="emphasis">/var/nfs/nfslog</em> file contains the actual NFS
transaction log records. The
<em class="emphasis">/etc/nfs/nfslog.conf</em> and
<em class="emphasis">/etc/default/nfslogd</em> files specify various
logging configuration values. The
<em class="emphasis">/var/nfs/fhpath</em> file contains the path mapping
information. The remaining two files are temporary and only needed to
help construct the NFS transaction log records. Each file will be
discussed in more detail
throughout<a name="INDEX-2264" />
<a name="INDEX-2265" /> <a name="INDEX-2266" /> this chapter.
</p>

<a name="nfs2-CHP-14-TABLE-2" /><h4 class="objtitle">Table 14-2. NFS server logging files </h4><table border="1">





<tr>
<th>
File</p>
</th>
<th>
Contents</p>
</th>
<th>
Creator/ Modifier</p>
</th>
<th>
Consumer</p>
</th>
</tr>


<tr>
<td>
/etc/nfs/nfslog.conf</p>
</td>
<td>
Logging configuration</p>
</td>
<td>
Administrator</p>
</td>
<td>
share, nfslogd</p>
</td>
</tr>
<tr>
<td>
/etc/default/nfslogd</p>
</td>
<td>
nfslogd-specific configuration</p>
</td>
<td>
Administrator</p>
</td>
<td>
nfslogd</p>
</td>
</tr>
<tr>
<td>
/etc/nfs/nfslogtab</p>
</td>
<td>
Information on location of the work buffer files</p>
</td>
<td>
share, unshare nfslogd</p>
</td>
<td>
nfslogd</p>
</td>
</tr>
<tr>
<td>
/var/nfs/nfslog</p>
</td>
<td>
NFS transaction log records</p>
</td>
<td>
nfslogd</p>
</td>
<td>
Administrator</p>
</td>
</tr>
<tr>
<td>
/var/nfs/nfslog_workbuffer</p>
</td>
<td>
RPC operations recorded by the kernel and consumed by the nfslogd
daemon
</p>
</td>
<td>
Unix kernel</p>
</td>
<td>
nfslogd</p>
</td>
</tr>
<tr>
<td>
/var/nfs/fhpath</p>
</td>
<td>
filehandle to path mapping</p>
</td>
<td>
nfslogd</p>
</td>
<td>
<a name="INDEX-2267" />
<a name="INDEX-2268" />nfslogd
</p>
</td>
</tr>

</table><p>

</div>
<a name="nfs2-CHP-14-SECT-6.2" /><div class="sect2">
<h3 class="sect2">14.6.2. Enabling NFS server logging</h3>

Before enabling logging on a filesystem, <a name="INDEX-2269" />
<a name="INDEX-2270" />make sure
to first define the default directory where the NFS log and working
files are to be created. Solaris ships with the default directory set
to <em class="emphasis">/var/nfs</em>. Make sure you have enough disk
space available in <em class="emphasis">/var/nfs</em> or set the default
directory to a different partition. Instructions on how to change the
default directory and how to spread the logs and files across
multiple partitions are provided in <a href="ch14_06.html#nfs2-CHP-14-SECT-6.3">Section 14.6.3, "NFS server logging configuration"</a>.
</p>

Once the location of the files has been specified, logging NFS
traffic on a filesystem is simple. First, export the filesystem using
the <em class="emphasis">-o</em> log directive. Second, start the
<em class="emphasis">nfslogd</em> daemon if it is not yet running. The NFS
log file will be created a few minutes later in the directory
previously specified, after the kernel has gathered enough
information to generate the NFS transaction records. Note that
setting the <em class="emphasis">-o</em> log directive in the
<em class="emphasis">/etc/dfs/dfstab</em> file will cause the
<em class="emphasis">nfslogd</em> daemon to be started automatically the
next time the machine is booted. The daemon will automatically detect
when other filesystems are shared with logging enabled.
</p>

The rest of the chapter explains the specifics of how the NFS Server
Logging mechanism works, its main components, and configuration
parameters. Enabling logging is straightforward, unfortunately
cleaning up working files after logging has been disabled requires
some manual work. We will explain this in <a href="ch14_06.html#nfs2-CHP-14-SECT-6.9">Section 14.6.9, "Disabling NFS server logging"</a>. 
</p>

To enable NFS Server Logging on a filesystem, the filesystem must
first be exported with the <em class="emphasis">-o log [=&lt;tag&gt;]</em>
directive:
</p>

<blockquote><pre class="code"># <tt class="userinput"><b>share -o log /export</b></tt></pre></blockquote>

When no <em class="emphasis">tag</em> is specified, the kernel will record
the temporary RPC information in the default work buffer
file <em class="emphasis">/var/nfs/nfslog_workbuffer_in_process.</em>
Again, this temporary file does not contain any information useful to
the user, instead it's used by the NFS Logging mechanism as a
temporary buffer. It is the <em class="emphasis">nfslogd</em> daemon that
reads this work buffer, processes its information, and generates the
NFS log file. By default, the NFS log file is stored in
<em class="emphasis">/var/nfs/nfslog</em>.
</p>

The <em class="emphasis">nfslogd</em> daemon must be running in order to
generate the NFS log file. Note that the daemon is started at boot
time only when one or more filesystems in
<em class="emphasis">/etc/dfs/dfstab</em> have the <em class="emphasis">-o
log</em> directive specified. If you share a filesystem
manually with logging enabled and the <em class="emphasis">nfslogd</em>
daemon had not previously been started, you must invoke it manually:
</p>

<blockquote><pre class="code"># <tt class="userinput"><b>/usr/lib/nfs/nfslogd</b></tt></pre></blockquote>

To assure that the <em class="emphasis">nfslogd</em> daemon is started
after a reboot, make sure <a name="INDEX-2271" /> <a name="INDEX-2272" />to specify the <em class="emphasis">-o
log</em> directive in <em class="emphasis">/etc/dfs/dfstab</em>.
</p>

</div>
<a name="nfs2-CHP-14-SECT-6.3" /><div class="sect2">
<h3 class="sect2">14.6.3. NFS server logging configuration</h3>

By default, the NFS log file, the temporary work<a name="INDEX-2273" /> <a name="INDEX-2274" />
<a name="INDEX-2275" />
buffer files, and the filehandle mapping tables are created in the
<em class="emphasis">/var/nfs</em> directory. These <a name="INDEX-2276" />defaults can be overridden by sharing the
filesystem with specific logging parameters associated with a logging
tag. Logging tags are defined in the
<em class="emphasis">/etc/nfs/nfslog.conf</em> file. Each entry in the
file consists of a mandatory tag identifier and one or more logging
parameters.
</p>

The following is a sample <em class="emphasis">/etc/nfs/nfslog.conf</em>
configuration<a name="INDEX-2277" /> file:
</p>

<blockquote><pre class="code"># NFS server log configuration file.
#
# &lt;tag&gt; [ defaultdir=&lt;dir_path&gt; ] \
#             [ log=&lt;logfile_path&gt; ] [ fhtable=&lt;table_path&gt; ] \
#            [ buffer=&lt;bufferfile_path&gt; ] [ logformat=basic|extended ]

global        defaultdir=/var/nfs \
	           log=logs/nfslog \
           fhtable=workfiles/fhtable buffer=workfiles/nfslog_workbuffer
eng          log=/export/eng/logs/nfslog
corp           defaultdir=/export/corp/logging
extended   logformat=extended log=extended_logs/nfslog</pre></blockquote>

The <em class="emphasis">global</em> tag specifies the default set of
values to be used when no tag is specified in the
<em class="emphasis">share</em> command. Note that the
<em class="emphasis">eng</em>, <em class="emphasis">corp,</em> and
<em class="emphasis">extended</em> tags do not specify all possible
parameters. The <em class="emphasis">global</em> values are used, unless
they are specifically replaced in the tag. Take for example:
</p>

<blockquote><pre class="code"># <tt class="userinput"><b>share -o log=eng /export/eng</b></tt></pre></blockquote>

where the NFS log file will be named <em class="emphasis">nfslog</em> and
located in the <em class="emphasis">/export/eng/logs</em> directory. The
work buffer file and filehandle table (explained later) remain under
<em class="emphasis">/var/nfs/workfiles</em>. Any of the
<em class="emphasis">global</em> values can be overridden by specific
tags.
</p>

The following describes each parameter in the configuration file:</p>

<dl>
<dt><i>defaultdir=&lt;path&gt;</i></dt>
<dd>
Specifies the default directory where all logging files are placed.
Every tag can specify its <em class="emphasis">defaultdir</em> and
override the value specified by the <em class="emphasis">global</em> tag.
This path is prepended to all relative paths specified by the other
parameters. <em class="emphasis">defaultdir</em> must be an absolute path,
or an error is reported by the <em class="emphasis">share</em> command. In
the previous sample configuration, filesystems shared with the
<em class="emphasis">global</em> tag will place their work files and NFS
log file in <em class="emphasis">/var/nfs</em>. Filesystems shared with
the <em class="emphasis">corp</em> tag place their work files in
<em class="emphasis">/export/corp/logging</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>log=&lt;path&gt;&lt;file&gt;</i></dt>
<dd>
Specifies the name and location of the NFS log file. This is the file
that actually contains the log of file transfers and the file that
the system administrator will be most interested in.
<em class="emphasis">defaultdir</em> is prepended to
<em class="emphasis">log</em> to determine the full path, except in the
case when <em class="emphasis">log</em> already identifies an absolute
path. Using the previous sample configuration, filesystems shared
with the <em class="emphasis">global</em> tag place the NFS log file in
<em class="emphasis">/var/nfs/logs/nfslog</em>.
</p>
</dd>

</dl>

<dl>
<dt><i>fhtable=&lt;path&gt;&lt;file&gt;</i></dt>
<dd>
Specifies the name and location of the filehandle to path mapping
database. NFS operations use filehandles and not filenames to
identify the file being worked on. The <em class="emphasis">nfslogd</em>
daemon builds a mapping of filehandles and stores it in the location
specified by <em class="emphasis">fhtable</em>. This is explained in
detail in <a href="ch14_06.html#nfs2-CHP-14-SECT-6.5">Section 14.6.5, "Filehandle to path mapping"</a>. The path concatenation
rules described earlier apply.
</p>
</dd>

</dl>

<dl>
<dt><i>buffer=&lt;path&gt;&lt;file&gt;</i></dt>
<dd>
Specifies the name and location of the temporary work buffer file,
where the kernel will store the raw RPC information to later be
consumed by the <em class="emphasis">nfslogd</em> daemon. This file is
intended for internal consumption of the <em class="emphasis">nfslogd</em>
daemon. The <em class="emphasis">nfslogd</em> daemon wakes up periodically
to consume the information stored in this file. The file is backed by
permanent storage, to prevent loss of RPC operation information on
reboot. The <em class="emphasis">nfslogd</em> daemon will remove the work
buffer file once it has processed the information. The path
concatenation rules described earlier apply.
</p>
</dd>

</dl>

<dl>
<dt><i>logformat=basic|extended</i></dt>
<dd>
Specifies the format of the NFS log file. Two values are valid: basic
and extended. The basic format is compatible with the log format
generated by the Washington University's FTPd utility. The
extended format provides more detailed information. Under basic
format, only reads and writes are recorded. Under extended format,
reads, writes, and directory modification operations (mkdir, rmdir,
and remove) are reported, as well as the NFS version and protocol
used in the operation. The basic format is assumed when no
<em class="emphasis">logformat</em> is specified. Note that the extended
format is not compatible with Washington University's FTPd log
format. Using the previous sample configuration, filesystems shared
with the <em class="emphasis">extended</em> tag will log extended
filesystem activity in the
<em class="emphasis">/var/nfs/extended_logs/nfslog</em> file.
</p>
</dd>

</dl>

<a href="ch14_06.html#nfs2-CHP-14-TABLE-3">Table 14-3</a> defines the values for the logging files
when filesystems are shared with the various tags.
</p>

<a name="nfs2-CHP-14-TABLE-3" /><h4 class="objtitle">Table 14-3. Logging files under different tags </h4><table border="1">





<tr>
<th>
Tag</p>
</th>
<th>
Log</p>
</th>
<th>
fhtable</p>
</th>
<th>
Buffer</p>
</th>
</tr>


<tr>
<td>
global</p>
</td>
<td>
/var/nfs/logs/nfslog</p>
</td>
<td>
/var/nfs/workfiles/fhtable</p>
</td>
<td>
/var/nfs/workfiles/nfslog_workbuffer</p>
</td>
</tr>
<tr>
<td>
eng</p>
</td>
<td>
/export/eng/logs/nfslog</p>
</td>
<td>
/var/nfs/workfiles/fhtable</p>
</td>
<td>
/var/nfs/workfiles/nfslog_workbuffer</p>
</td>
</tr>
<tr>
<td>
corp</p>
</td>
<td>
/export/corp/logging/logs/nfslog</p>
</td>
<td>
/export/corp/logging/workfiles/fhtable</p>
</td>
<td>
/export/corp/logging/workfiles/nfslog_workbuffer</p>
</td>
</tr>
<tr>
<td>
extended</p>
</td>
<td>
/var/nfs/extended_logs/nfslog</p>
</td>
<td>
/var/nfs/workfiles/fhtable</p>
</td>
<td>
/var/nfs/workfiles/nfslog_workbfuffer</p>
</td>
</tr>

</table><p>

The temporary work buffers can grow large in a hurry, therefore it
may not be a good idea to keep them in the default directory
<em class="emphasis">/var/nfs</em>, especially when
<em class="emphasis">/va</em>r is fairly small. It is recommended to
either spread them out among the filesystems they monitor, or place
them in a dedicated partition. This will allow space in your
<em class="emphasis">/var</em> partition to be used for other
administration tasks, such as storing core files, printer spool
directories, and other system logs.
</p>

<a name="nfs2-CHP-14-SECT-6.3.1" /><div class="sect3">
<h3 class="sect3">14.6.3.1. Basic versus extended log format</h3>

Logging using the basic format only
reports<a name="INDEX-2278" />
<a name="INDEX-2279" /> <a name="INDEX-2280" /> <a name="INDEX-2281" /> file uploads and downloads. On the other
hand, logging using the extended format provides more detailed
information of filesystem activity, but may be incompatible with
existing tools that process WU-Ftpd logs. Tools that expect a single
character identifier in the <em class="emphasis">operation</em> field will
not understand the multicharacter description of the extended format.
Home-grown scripts can be easily modified to understand the richer
format. Logging using the extended format reports directory creation,
directory removal, and file removal, as well as file reads
(downloads) and file writes (uploads). Each record indicates the NFS
version and protocol used during access.
</p>

Let us explore the differences between the two logs by comparing the
logged information that results from executing the same sequence of
commands against the NFS server <em class="emphasis">zeus</em>. First, the
server exports the filesystem using the <em class="emphasis">extended</em>
tag previously defined in the
<em class="emphasis">/etc/nfs/nfslog.conf</em> file:
</p>

<blockquote><pre class="code">zeus<tt class="userinput"><b># share -o log=extended /export/home</b></tt> </pre></blockquote>

Next, the client executes the following sequence of commands:</p>

<blockquote><pre class="code">rome<tt class="userinput"><b>% cd /net/zeus/export/home</b></tt>
rome<tt class="userinput"><b>% mkdir test</b></tt>
rome<tt class="userinput"><b>% mkfile 64k 64k-file</b></tt>
rome<tt class="userinput"><b>% mv 64k-file test</b></tt>
rome<tt class="userinput"><b>% rm test/64k-file</b></tt>
rome%<tt class="userinput"><b> rmdir test</b></tt>
rome<tt class="userinput"><b>% dd if=128k-file of=/dev/null</b></tt>
256+0 records in
256+0 records out</pre></blockquote>

The resulting extended format log on the server reflects
corresponding NFS operations:
</p>

<blockquote><pre class="code">zeus<tt class="userinput"><b># cat /var/nfs/extended_logs/nfslog</b></tt>
Mon Jul 31 11:00:05 2000 0 rome 0 /export/home/test b _ mkdir r 19069 nfs3-tcp 0 *
Mon Jul 31 11:00:33 2000 0 rome 0 /export/home/64k-file b _ create r 19069 nfs3-
tcp 0 *
Mon Jul 31 11:00:33 2000 0 rome 65536 /export/home/64k-file b _ write r 19069 
nfs3-tcp 0 *
Mon Jul 31 11:00:49 2000 0 rome 0 /export/home/64k-file-&gt;/export/home/test/64k-
file b _ rename r 19069 nfs3-tcp 0 *
Mon Jul 31 11:00:59 2000 0 rome 0 /export/home/test/64k-file b _ remove r 19069 
nfs3-tcp 0 *
Mon Jul 31 11:01:01 2000 0 rome 0 /export/home/test b _ rmdir r 19069 nfs3-tcp 0 *
Mon Jul 31 11:01:47 2000 0 rome 131072 /export/home/128k-file b _ read r 19069 
nfs3-tcp 0 *</pre></blockquote>

Notice that the <em class="emphasis">mkfile</em> operation generated two
log entries, a 0-byte file, create, followed by a 64K write. The
rename operation lists the original name followed by an arrow
pointing to the new name. File and directory deletions are also
logged. The <em class="emphasis">nfs3-tcp</em> field indicates the
protocol and version used: NFS Version 3 over TCP.
</p>

Now let us compare against the basic log generated by the same
sequence of client commands. First, let us reshare the filesystem
with the basic log format. It is highly recommended to never mix
extended and basic log records in the same file. This will make
post-processing of the log file much easier. Our example places
extended logs in <em class="emphasis">/var/nfs/extended_logs/nfslog</em>
and basic logs in <em class="emphasis">/var/nfs/logs/nfslog</em>:
</p>

<blockquote><pre class="code">zeus<tt class="userinput"><b># share -o log /export/home</b></tt></pre></blockquote>

Next, the client executes the same sequence of commands listed
earlier. The resulting basic format log on the server only shows the
file upload (incoming operation denoted by <em class="emphasis">i</em>)
and the file download (outgoing operation denoted by
<em class="emphasis">o</em>). The directory creation, directory removal,
and file rename are not logged in the basic format. Notice <a name="INDEX-2282" /> <a name="INDEX-2283" /> <a name="INDEX-2284" />that the NFS version
and protocol type are not specified either:
</p>

<blockquote><pre class="code">zeus<tt class="userinput"><b># cat /var/nfs/logs/nfslog</b></tt>
Mon Jul 31 11:35:08 2000 0 rome 65536 /export/home/64k-file b _ i r 19069 nfs 0 *
Mon Jul 31 11:35:25 2000 0 rome 131072 /export/home/128k-file b _ o r 19069 nfs 0 *</pre></blockquote>

</div>
</div>
<a name="nfs2-CHP-14-SECT-6.4" /><div class="sect2">
<h3 class="sect2">14.6.4. The nfslogd daemon</h3>

It is the <em class="emphasis">nfslogd</em> daemon that generates the
ultimate <a name="INDEX-2285" />
<a name="INDEX-2286" /> <a name="INDEX-2287" />NFS
log file. The daemon periodically wakes up to process the contents of
the work buffer file created by the kernel, performs hostname and
pathname mappings, and generates the file transfer log record. Since
the filesystem can be reshared with logging disabled, or simply be
unshared, the <em class="emphasis">nfslogd</em> daemon cannot rely on the
list of exported filesystems to locate the work buffer files. So how
exactly does the <em class="emphasis">nfslogd</em> daemon locate the work
buffer files?
</p>

When a filesystem is exported with logging enabled, the
<em class="emphasis">share</em> command adds a record to the
<em class="emphasis">/etc/nfs/nfslogtab</em> file indicating the location
of the work buffer file, the filesystem shared, the tag used to share
the filesystem, and a 1 to indicate that the filesystem is currently
exported with logging enabled. This system table is used to keep
track of the location of the work buffer files so they can be
processed at a later time, even after the filesystem is unshared, or
the server is rebooted. The <em class="emphasis">nfslogd</em> daemon uses
this system file to find the location of the next work buffer file
that needs to be processed. The daemon removes the
<em class="emphasis">/etc/nfs/nfslogtab</em> entry for the work buffer
file after processing if the corresponding filesystem is no longer
exported. The entry will not be removed if the filesystem remains
exported.
</p>

The <em class="emphasis">nfslogd</em> daemon removes the work buffer file
once it has processed the information. The kernel creates a new work
buffer file when more RPC requests arrive. To be exact, the work
buffer file currently accessed by the kernel has the
<em class="emphasis">_in_process</em> string appended to its name (name
specified by the <em class="emphasis">buffer</em> parameter in
<em class="emphasis">/etc/nfs/nfslog.conf</em> ). The daemon, asks the
kernel to rename the buffer to the name specified in the
configuration file once it is ready to process it. At this point the
kernel will again create a new buffer file with the string appended
and start writing to the new file. This means that the kernel and the
<em class="emphasis">nfslogd</em> daemon are always working on their own
work buffer file, without stepping on each others' toes. The
<em class="emphasis">nfslogd</em> daemon will remove the work buffer file
once it has processed the information.
</p>

You will notice that log records do not show up immediately on the
log after a client accesses the file or directory on the server. This
occurs because the <em class="emphasis">nfslogd</em> daemon waits for
enough RPC information to gather in the work buffer before it can
process it. By default it will wait five minutes. This time can be
shortened or lengthened by tuning the value of IDLE_TIME in
<em class="emphasis">/etc/default/nfslogd</em>.
</p>

<a name="nfs2-CHP-14-SECT-6.4.1" /><div class="sect3">
<h3 class="sect3">14.6.4.1. Consolidating file transfer information</h3>

The NFS protocol was not designed to<a name="INDEX-2288" /> be a file transfer protocol,
instead it was designed to be a file access protocol. NFS file
operations map nicely to Unix filesystem calls and as such, its file
data access and modification mechanisms operate on regions of files.
This enables NFS to minimize the amount of data transfer required
between server and client, when only small portions of the file are
needed. The NFS protocol enables reads and writes of arbitrary number
of bytes at any given offset, in any given order. NFS clients are not
required to read a file on an NFS server in any given order, they may
start in the middle and read an arbitrary number of bytes at any
given offset.
</p>

The random byte access, added to the fact that NFS Versions 2 and 3
do not define an open or close operation, make it hard to determine
when an NFS client is done reading or writing a file. Despite this
limitation, the <em class="emphasis">nfslogd</em> daemon does a decent job
identifying file transfers by using various heuristics to determine
when to generate <a name="INDEX-2289" /> <a name="INDEX-2290" /> <a name="INDEX-2291" />the file transfer record.
</p>

</div>
</div>
<a name="nfs2-CHP-14-SECT-6.5" /><div class="sect2">
<h3 class="sect2">14.6.5. Filehandle to path mapping</h3>

Most NFS operations take a filehandle<a name="INDEX-2292" /> <a name="INDEX-2293" /> as an argument, or return a
filehandle as a result of the operation. In the NFS protocol, a
filehandle serves to identify a file or a directory. Filehandles
contain all the information the server needs to distinguish an
individual file or directory. To the client, the filehandle is
opaque. The client stores the filehandles for use in a later request.
It is the server that generates the filehandle:
</p>

<blockquote><pre class="code">  1   0.00000       rome -&gt; zeus      NFS C LOOKUP3 FH=0222 foo.tar.Z
  2   0.00176       zeus -&gt; rome      NFS R LOOKUP3 OK FH=EEAB
...
  9   0.00091       rome -&gt; zeus      NFS C READ3 FH=EEAB at 0 for 32768
...</pre></blockquote>

Consider packets 1, 2, and 9 from the snoop trace presented earlier
in this chapter. The client must first obtain the filehandle for the
file <em class="emphasis">foo.tar.Z</em>, before it can request to read
its contents. This is because the NFS READ procedure takes the
filehandle as an argument and not the filename. The client obtains
the filehandle by first invoking the LOOKUP procedure, which takes as
arguments the name of the file requested and the filehandle of the
directory where it is located. Note that the directory filehandle
must itself first be obtained by a previous LOOKUP or MOUNT
operation.
</p>

Unfortunately, NFS server implementations today do not provide a
mechanism to obtain a filename given a filehandle. This would require
the kernel to be able to obtain a path given a vnode, which is not
possible today in Solaris. To overcome this limitation, the
<em class="emphasis">nfslogd</em> daemon builds a mapping table of
filehandle to pathnames by monitoring all NFS operations that
generate or modify filehandles. It is from this table that it obtains
the pathname for the file transfer log record. This filehandle to
pathname mapping table is by default stored in the file
<em class="emphasis">/var/nfs/fhtable</em>. This can be overridden by
specifying a new value for <em class="emphasis">fhtable</em> in
<em class="emphasis">/etc/nfs/nfslog.conf</em>.
</p>

In order to successfully resolve all filehandles, the filesystem must
be shared with logging enabled from the start. The
<em class="emphasis">nfslogd</em> daemon will not be able to resolve all
mappings when logging is enabled on a previously shared filesystem
for which clients have already obtained filehandles. The filehandle
mapping information can only be built from the RPC information
captured while logging is enabled on the filesystem. This means that
if logging is temporarily disabled, a potentially large number of
filehandle transactions will not be captured and the
<em class="emphasis">nfslogd</em> daemon will not be able to reconstruct
the pathname for all filehandles. If a filehandle can not be
resolved, it will be printed on the NFS log transaction record
instead of printing the corresponding (but unknown) pathname.
</p>

The filehandle mapping table needs to be backed by permanent storage
since it has to survive server reboots. There is no limit for the
amount of time that NFS clients hold on to filehandles. A client may
obtain a filehandle for a file, read it today and read it again five
days from now without having to reacquire the filehandle (not
encountered often in practice). Filehandles are even valid across
server reboots.
</p>

Ideally the filehandle mapping table would only go away when the
filesystem is destroyed. The problem is that the table can get pretty
large since it could potentially contain a mapping for every entry in
the filesystem. Not all installations can afford reserving this much
storage space for a utility table. Therefore, in order to preserve
disk space, the <em class="emphasis">nfslogd</em> daemon will periodically
prune the oldest contents of the mapping table. It removes filehandle
entries that have not been accessed since the last time the pruning
process was performed. This process is automatic, the
<em class="emphasis">nfslogd</em> daemon will prune the table every seven
days by default. This can be overridden by setting PRUNE_TIMEOUT in
<em class="emphasis">/etc/default/nfslogd</em>. This value specifies the
number of hours between prunings. Making this value too small can
increase the risk that a client may have held on to a filehandle
longer than the PRUNE_TIMEOUT and perform an NFS operation after the
filehandle has been removed from the table. In such a case, the
<em class="emphasis">nfslogd</em> daemon will not be able to resolve the
pathname and the NFS log will include the filehandle instead of the
pathname. Pruning of the table can effectively be disabled by setting
the PRUNE_TIMEOUT to INT_MAX. Be aware that this may lead to very
large tables, potentially causing problems exceeding the database
maximum values. This is therefore highly discouraged, since in
practice the chance of NFS clients holding on to filehandles for more
than a few days without <a name="INDEX-2294" /> <a name="INDEX-2295" />using them is extremely small. The
<em class="emphasis">nfslogd</em> daemon uses ndbm<a href="#FOOTNOTE-37">[37]</a> to manage the filehandle mapping
table.
</p><blockquote class="footnote"> <a name="FOOTNOTE-37" />[37]See
dbm_clearerr(3C).</p> </blockquote>

</div>
<a name="nfs2-CHP-14-SECT-6.6" /><div class="sect2">
<h3 class="sect2">14.6.6. NFS log cycling</h3>

The <em class="emphasis">nfslogd</em> daemon periodically cycles the
<a name="INDEX-2296" />
<a name="INDEX-2297" />
<a name="INDEX-2298" />logs to prevent an individual file
from becoming extremely large. By default, the ten most current NFS
log files are located in <em class="emphasis">/var/nfs</em> and named
<em class="emphasis">nfslog</em>, <em class="emphasis">nfslog.0</em>, through
<em class="emphasis">nfslog.9</em>. The file <em class="emphasis">nfslog</em>
being the most recent, followed by <em class="emphasis">nfslog.1</em> and
<em class="emphasis">nfslog.9</em> being the oldest. The log files are
cycled every 24 hours, saving up to 10 days worth of logs. The number
of logs saved can be increased by setting MAX_LOGS_PRESERVE in
<em class="emphasis">/etc/default/nfslogd</em>. The cycle frequency can be
modified by setting CYCLE_FREQUENCY in the same file.
</p>

</div>
<a name="nfs2-CHP-14-SECT-6.7" /><div class="sect2">
<h3 class="sect2">14.6.7. Manipulating NFS log files</h3>

Sometimes it may be desirable to have the
<em class="emphasis">nfslogd</em> daemon close the current file, and log
to a fresh new file. The daemon holds an open file descriptor to the
log file, so renaming it or copying it somewhere else may not achieve
the desired effect. Make sure to first shut down the daemon before
manipulating the log files. To shut down the daemon, send it a SIGHUP
signal. This will give the daemon enough time to flush pending
transactions to the log file. You can use the Solaris
<em class="emphasis">pkill</em> command to send the signal to the daemon.
Note that the daemon can take a few seconds to flush the information:
</p>

<blockquote><pre class="code"># <tt class="userinput"><b>pkill -HUP -x -u 0 nfslogd</b></tt> </pre></blockquote>

Sending it a SIGTERM signal will simply close the buffer files, but
pending transactions will not be logged to the file and will be
discarded.
</p>

</div>
<a name="nfs2-CHP-14-SECT-6.8" /><div class="sect2">
<h3 class="sect2">14.6.8. Other configuration parameters</h3>

The configuration parameters<a name="INDEX-2299" /> <a name="INDEX-2300" /> in
the <em class="emphasis">/etc/default/nfslogd</em> tune the behavior of
the <em class="emphasis">nfslogd</em> daemon. The
<em class="emphasis">nfslogd</em> daemon reads the configuration
parameters when it starts, therefore any changes to the parameters
will take effect the next time the daemon is started. Here is a list
of the parameters:
</p>

<dl>
<dt><i>UMASK</i></dt>
<dd>
Used to set the file mode used<a name="INDEX-2301" /> to create the log files, work
buffer files, and filehandle mapping tables. Needless to say one has
to be extremely careful setting this value, as it could open the
doors for unathorized access to the log and work files. The default
is 0x137, which gives read/write access to root, read access to the
group that started the <em class="emphasis">nfslogd</em> daemon, and no
access to other.
</p>
</dd>

</dl>

<dl>
<dt><i>MIN_PROCESSING_SIZE</i></dt>
<dd>
The <em class="emphasis">nfslogd</em> daemon waits until
MIN_PROCESSING_SIZE bytes <a name="INDEX-2302" />are gathered in the
work buffer file before it starts processing any information. The
idea is to wait long enough for information to gather to make the
processing worth while. Note that the <em class="emphasis">nfslogd</em>
daemon will process the work buffer regardless of the size after an
implementation timer fires indicating that the work buffer has been
ignored for too long. The default value is 512 Kb.
</p>
</dd>

</dl>

<dl>
<dt><i>IDLE_TIME</i></dt>
<dd>
The <em class="emphasis">nfslogd</em> daemon sleeps up to IDLE_TIME
<a name="INDEX-2303" />seconds waiting for information to be
gathered in the work buffer files. This value indirectly affects the
frequency with which the <em class="emphasis">nfslogd</em> daemon checks
updates of the file <em class="emphasis">/etc/nfs/nfslog.conf</em>.
Increasing this value too much will cause the temporary work buffer
files to become large, potentially using more disk space than
desired. Making this value too short will cause the
<em class="emphasis">nfslogd</em> daemon to wake up frequently and
potentially have nothing to do since the MIN_PROCESSING_SIZE of its
buffers may not have been reached.
</p>
</dd>

</dl>

<dl>
<dt><i>MAX_LOGS_PRESERVE</i></dt>
<dd>
The <em class="emphasis">nfslogd</em> daemon periodically cycles the logs
in <a name="INDEX-2304" />order to keep their size manageable. This
value specifies the maximum number of logs to save in the log
directory. When this value is reached, the oldest log is discarded to
make room for a new log. The logs are saved with a numbered
extension, beginning with .0 through .MAX_LOGS_PRESERVE-1. The oldest
log will be the one with the highest numbered extension.
</p>

Consider the following three tags:</p>

<blockquote><pre class="code"><i class="lineannotation">Excerpt from /etc/nfs/nfslog.conf:</i>
sales      log=/export/logs/nfslog fhtable=sales-table
corp       log=/export/logs/nfslog fhtable=corp-table
eng        log=/export/logs/eng/englog

<i class="lineannotation">Excerpt from /etc/default/nfslogd:</i>
MAX_LOGS_PRESERVE=10</pre></blockquote>

Both the <em class="emphasis">sales</em> and <em class="emphasis">corp</em>
tags send the final log records to
<em class="emphasis">/export/logs/nfslog</em>. The
<em class="emphasis">eng</em> tag sends the log records to
<em class="emphasis">/export/logs/eng/nfslog</em>. You will have a total
of up to 10 log files named <em class="emphasis">nfslog</em>,
<em class="emphasis">nfslog.0</em>, ..., <em class="emphasis">nfslog.9</em> in
<em class="emphasis">/export/logs.</em> Similarly, you will have a total
of up to ten log files named <em class="emphasis">englog</em>,
<em class="emphasis">englog.0</em>, ..., <em class="emphasis">englog.9</em> in
<em class="emphasis">/export/logs/eng</em>. Notice that the fact that two
tags use the same log file does not affect the total number of logs
preserved.
</p>
</dd>

</dl>


<dl>
<dt><i>CYCLE_FREQUENCY</i></dt>
<dd>
Specifies the frequency with which log
files<a name="INDEX-2305" /> are cycled (see MAX_LOGS_PRESERVE). The
value is specified in hours. This helps keep the log file size
manageable. The default is to cycle every 24 hours.
</p>
</dd>

</dl>

<dl>
<dt><i>MAPPING_UPDATE_INTERVAL</i></dt>
<dd>
Specifies the time interval, in seconds, between updates of
<a name="INDEX-2306" />the records in the filehandle mapping
table. Ideally the access time of entries queried in the mapping
table should be updated on every access. In practice, updates of this
table are much more expensive than queries. Instead of updating the
access time of a record each time the record is accessed, the access
time is updated only when the last update is older than
MAPPING_UPDATE_INTERVAL seconds. By default updates are performed
once per day. Make sure this value is always less than the value
specified by PRUNE_TIMEOUT, otherwise all of the entries in the
filehandle mapping tables will be considered timed out.
</p>
</dd>

</dl>

<dl>
<dt><i>PRUNE_TIMEOUT</i></dt>
<dd>
Specifies how frequent the pruning of the
filehandle<a name="INDEX-2307" /> mapping tables is invoked. This value
represents the minimum number of hours that a record is guaranteed to
remain in the mapping table. The default value of seven days (168
hours) instructs the <em class="emphasis">nfslogd</em> daemon to perform
the database pruning every seven days and remove the records that are
older than seven days. Note that filehandles can remain in the
database for up to 14 days. This can occur when a record is created
immediately after the pruning process has finished. Seven days later
the record will not be pruned because it is only six days and hours
old. The record will be removed until the next pruning cycle,
assuming no client accesses the filehandle within that time. The
MAPPING_UPDATE_INTERVAL may need to be updated <a name="INDEX-2308" /> <a name="INDEX-2309" />accordingly.
</p>
</dd>

</dl>

</div>
<a name="nfs2-CHP-14-SECT-6.9" /><div class="sect2">
<h3 class="sect2">14.6.9. Disabling NFS server logging</h3>

Unfortunately, disabling logging requires some <a name="INDEX-2310" /> <a name="INDEX-2311" />manual
cleanup. Unsharing or resharing a filesystem without the <em class="emphasis">-o
log</em> directive stops the kernel from storing information
into the work buffer file. You must allow the nfslogd daemon enough
time to process the work buffer file before shutting it down. The
daemon will notice that it needs to process the work buffer file once
it wakes up after its IDLE_TIME has been exceeded.
</p>

Once the work buffer file has been processed and removed by the
nfslogd daemon, the <em class="emphasis">nfslogd</em> daemon can manually
be shutdown by sending it a SIGHUP signal. This allows the daemon to
flush the pending NFS log information before it is stopped. Sending
any other type of signal may cause the daemon to be unable to flush
the last few records to the log.
</p>

There is no way to distinguish between a graceful server shutdown and
the case when logging is being completely disabled. For this reason,
the mapping tables are not removed when the filesystem is unshared,
or the daemon is stopped. The system administrator needs to remove
the filehandle mapping tables manually when he/she wants to reclaim
the filesystem space and knows that logging is being permanently
disabled <a name="INDEX-2312" />
<a name="INDEX-2313" />for
<a name="INDEX-2314" />
<a name="INDEX-2315" />
<a name="INDEX-2316" />this
filesystem.<a href="#FOOTNOTE-38">[38]</a>
</p><blockquote class="footnote"> <a name="FOOTNOTE-38" />[38]Keep in mind that if logging is later
reenabled, there will be some filehandles that the <em class="emphasis">nfslogd</em>
daemon will not be able to resolve since they were
obtained by clients while logging was not enabled. If the filehandle
mapping table is removed, then the problem is aggravated.</p>
</blockquote>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch14_05.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch14_07.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">14.5. Version 2 and Version 3 differences</td><td align="center" valign="top" width="228"><a href="index/index.html"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">14.7. Time synchronization</td></tr></table><div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.html">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,84,90" href="../index.html" /><area shape="rect" coords="86,-7,176,90" href="../ssh/index.html" /><area shape="rect" coords="178,0,265,101" href="../tcp/index.html" /><area shape="rect" coords="266,0,333,90" href="index.html" /><area shape="rect" coords="334,-1,429,93" href="../snmp/index.html" /><area shape="rect" coords="431,0,529,116" href="../tshoot/index.html" /><area shape="rect" coords="534,0,594,104" href="../dns/index.html" /><area shape="rect" coords="595,1,704,108" href="../fire/index-2.html" /></map>

</body>
<!-- Mirrored from nnc3.com/mags/Networking2/nfs/ch14_06.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:42 GMT -->
</html>