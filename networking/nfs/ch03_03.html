<html>
<!-- Mirrored from nnc3.com/mags/Networking2/nfs/ch03_03.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:39 GMT -->
<head><title>Files managed under NIS (Managing NFS and NIS, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Hal Stern, Mike Eisler and Ricardo Labiaga" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="1565925106L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Managing NFS and NIS, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.html" alt="Managing NFS &amp; NIS" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.html" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch03_02.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"></a></td><td align="right" valign="top" width="228"><a href="ch03_04.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table><div>



<h2 class="sect1">3.3. Files managed under NIS</h2>


Now that we've walked through the <a name="INDEX-449" /> <a name="INDEX-450" />setup procedure, we will discuss
how the NIS maps relate to the files that they replace. In
particular, we'll discuss how to modify the files that are
appended by NIS so they can take advantage of NIS features. We will
also pay special attention to the <em class="emphasis">netgroups</em> NIS
map, a confusing but nevertheless important part of the overall
picture.</p>


<a href="ch03_03.html#nfs2-CHP-3-TABLE-2">Table 3-2</a> lists the most common files managed by
NIS. Not all vendors use NIS for all of these files, so it is best to
check your documentation
<a name="INDEX-451" />
<a name="INDEX-452" />for a list of NIS-supported files.</p>


<a name="nfs2-CHP-3-TABLE-2" /><h4 class="objtitle">Table 3-2. Summary of NIS maps </h4><table border="1">






<tr>
<th>
Map Name</p></th>
<th>
Nickname</p></th>
<th>
Access By</p></th>
<th>
Contains</p></th>
<th>
Default Integration</p></th>
</tr>




<tr>
<td>
auto.*</p></td>
<td>&nbsp;</td>
<td>
Map key</p></td>
<td>
/etc/auto_*</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
bootparams</p></td>
<td>&nbsp;</td>
<td>
Hostname</p></td>
<td>
/etc/bootparams</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
ethers.byname</p></td>
<td>
ethers</p></td>
<td>
Hostname</p></td>
<td>
/etc/ethers</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
ethers.byaddr</p></td>
<td>&nbsp;</td>
<td>
MAC address</p></td>
<td>
/etc/ethers</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
group.byname</p></td>
<td>
group</p></td>
<td>
Group name</p></td>
<td>
/etc/group</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
group.bygid</p></td>
<td>&nbsp;</td>
<td>
Group ID</p></td>
<td>
/etc/group</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
hosts.byname</p></td>
<td>
hosts</p></td>
<td>
Hostname</p></td>
<td>
/etc/hosts</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
hosts.byaddr</p></td>
<td>&nbsp;</td>
<td>
IP address</p></td>
<td>
/etc/hosts</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
ipnodes.byname</p></td>
<td>
ipnodes</p></td>
<td>
Hostname</p></td>
<td>
/etc/inet/ipnodes</p></td>
<td>
None; only integrated if IPv6 enabled</p></td>
</tr>

<tr>
<td>
ipnodes.byaddr</p></td>
<td>&nbsp;</td>
<td>
IP address</p></td>
<td>
/etc/inet/ipnodes</p></td>
<td>
None; only integrated if IPv6 enabled</p></td>
</tr>

<tr>
<td>
mail.aliases</p></td>
<td>
aliases</p></td>
<td>
Alias name</p></td>
<td>
/etc/aliases</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
mail.byaddr</p></td>
<td>&nbsp;</td>
<td>
Expanded alias</p></td>
<td>
/etc/aliases</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
netgroup.byhost</p></td>
<td>&nbsp;</td>
<td>
Hostname</p></td>
<td>
/etc/netgroup</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
netgroup.byuser</p></td>
<td>&nbsp;</td>
<td>
Username</p></td>
<td>
/etc/netgroup</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
netid.byname</p></td>
<td>&nbsp;</td>
<td>
Username</p></td>
<td>
UID &amp; GID info</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
netmasks.byaddr</p></td>
<td>&nbsp;</td>
<td>
IP address</p></td>
<td>
/etc/netmasks</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
networks.byname</p></td>
<td>&nbsp;</td>
<td>
Network name</p></td>
<td>
/etc/networks</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
networks.byaddr</p></td>
<td>&nbsp;</td>
<td>
IP address</p></td>
<td>
/etc/networks</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
passwd.byname</p></td>
<td>
passwd</p></td>
<td>
Username</p></td>
<td>
/etc/passwd</p>


/etc/shadow</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
passwd.byuid</p></td>
<td>&nbsp;</td>
<td>
User ID</p></td>
<td>
/etc/passwd</p>


/etc/shadow</p></td>
<td>
Append</p></td>
</tr>

<tr>
<td>
publickey.byname</p></td>
<td>&nbsp;</td>
<td>
Principal name</p></td>
<td>
/etc/publickey</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
protocols.bynumber</p></td>
<td>
protocols</p></td>
<td>
Port number</p></td>
<td>
/etc/protocols</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
protocols.byname</p></td>
<td>&nbsp;</td>
<td>
Protocol name</p></td>
<td>
/etc/protocols</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
rpc.bynumber</p></td>
<td>&nbsp;</td>
<td>
RPC number</p></td>
<td>
/etc/rpc</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
services.byname</p></td>
<td>
services</p></td>
<td>
Service name</p></td>
<td>
/etc/services</p></td>
<td>
Replace</p></td>
</tr>

<tr>
<td>
ypservers</p></td>
<td>&nbsp;</td>
<td>
Hostname</p></td>
<td>
NIS server names</p></td>
<td>
Replace</p></td>
</tr>


</table><p>


It's now time to face up to some distortions we've been
making for the sake of simplicity. We've assumed that
there's a one-to-one correspondence between files and maps. In
fact, there are usually several maps for each file. A map really
corresponds to a particular way of accessing a file: for example, the
<em class="emphasis">passwd.byname</em> map looks
<a name="INDEX-453" />
<a name="INDEX-454" />up
data in the password database by username. There's also a
<em class="emphasis">passwd.byuid</em> that looks up users according to
their user ID number. There could be (but there aren't)
additional maps that looked up users on the basis of their group ID
number, home directory, or even their choice of login shell. To make
things a bit easier, the most commonly
used<a name="INDEX-455" />
<a name="INDEX-456" /> maps have
"nicknames," which correspond directly to the name of the
original file: for example, the nickname for
<em class="emphasis">passwd.byname</em> is simply
<em class="emphasis">passwd</em>. Using nicknames as if they were map
names rarely causes problems  --  but it's important to
realize that there is a distinction. It's also important to
<a name="INDEX-457" /> <a name="INDEX-458" />realize that nicknames are recognized by
only two NIS utilities: <em class="emphasis">ypmatch</em> and
<em class="emphasis">ypcat</em>.</p>


Another distortion: this is the first time we've
<a name="INDEX-459" />
<a name="INDEX-460" />seen
the <em class="emphasis">netid.byname</em> map. On the master NIS server,
this map is not based on any single source file, but
instead<a name="INDEX-461" />
is derived from information in the group, password, and hosts files,
<a name="INDEX-462" />via
<em class="emphasis">/var/yp/Makefile</em>. It contains one entry for each
user in the password file. The data associated with the username is a
list of every group to which the user belongs. The
<em class="emphasis">netid</em> is used to determine group memberships
quickly when a user logs in. Instead of reading the entire
<em class="emphasis">group</em> map, searching for the user's name,
the <em class="emphasis">login</em> process performs a single map lookup
on the <em class="emphasis">netid</em> map. You usually don't have
to worry about this map  --  it will be built for you as needed
 --  but you should be aware that it exists. If NIS is not
running, and if an NIS client has an <em class="emphasis">/etc/netid</em>
file, then the information will be read from
<em class="emphasis">/etc/netid</em>.</p>


<a name="nfs2-CHP-3-SECT-3.1" /><div class="sect2">
<h3 class="sect2">3.3.1. Working with the maps</h3>


Earlier, we introduced the concept <a name="INDEX-463" />of replaced files and appended files.
Now, we'll discuss how to work with these files. First,
let's review: these are important concepts, so repetition is
helpful. If a map <em class="emphasis">replaces</em> the local file, the
file is ignored once NIS is running. Aside from making sure that
misplaced optimism doesn't lead you to delete the files that
were distributed with your system, there's nothing interesting
that you can do with these replaced files. We won't have
anything further to say about them.</p>


Conversely, local files that are <a name="INDEX-464" /><em class="emphasis">appended</em>
to by NIS maps are always consulted first, even if NIS is running.
The password file is a good example of a file augmented by NIS. You
may want to give some users access to one or two machines, and not
include them in the NIS password map. The solution to this problem is
to put these users into the local <em class="emphasis">passwd</em> file,
but not into the master <em class="emphasis">passwd</em> file on the
master server. The local password file is always read before
<em class="emphasis">getpwuid( )</em> goes to an NIS server.
<a name="INDEX-465" />
<a name="INDEX-466" /> <a name="INDEX-467" />Password-file reading routines find locally
defined users as well as those in the NIS map, and the search order
of "local, then NIS" allows local password file entries
to override values in the NIS map. Similarly, the local aliases file
can be used to override entries in the NIS mail aliases map, setting
up machine-specific expansion of one or more aliases.</p>


There is yet another group of files that can be augmented with data
from NIS. These files are not managed by NIS directly, but you can
add special entries referring to the NIS database (in particular, the
<em class="emphasis">netgroups</em> map).
Such<a name="INDEX-468" /> <a name="INDEX-469" /> files include
<em class="emphasis">hosts.equiv</em>
and<a name="INDEX-470" />
<a name="INDEX-471" />
<em class="emphasis">.rhosts</em>. We won't discuss these files in
this chapter; we will treat them as the need arises. For example, we
will discuss <em class="emphasis">hosts.equiv</em> in <a href="ch12_01.html">Chapter 12, "Network Security"</a>.</p>


Now we're going to discuss the special
<em class="emphasis">netgroups</em> map. This new database is the basis
for the most useful extensions to the standard administrative files;
it is what prevents NIS from becoming a rigid, inflexible system.
After our discussion of netgroups, we will pay special attention to
the appended<a name="INDEX-472" /> files.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.2" /><div class="sect2">
<h3 class="sect2">3.3.2. Netgroups</h3>


In addition to the standard password, <a name="INDEX-473" />
<a name="INDEX-474" />group,
and host file databases, NIS introduces a new database for creating
sets of users and hosts called the <em class="emphasis">netgroup</em>s
map. The user and hostname fields are used to define groups (of hosts
or users) for administrative purposes. For example, to define a
subset of the users in the <em class="emphasis">passwd</em> map that
should be given access to a specific machine, you can create a
netgroup for those users.</p>


<a name="INDEX-475" /><a name="INDEX-476" /><a name="INDEX-477" /><a name="INDEX-478" />A netgroup is a set of triples of
the form:</p>


<blockquote><pre class="code">(hostname, username, domain name)</pre></blockquote>


A single netgroup contains one or more of these triples. Host and
usernames have their usual meanings, but a domain name in this
instance refers to the NIS domain in which the netgroup is valid. If
an entry in the triple is left blank, that field becomes a wildcard.
If the entry is specified as a dash (<tt class="literal">-</tt>), the field
can take no value.</p>


Netgroups are typically used to augment other maps and files; for
example, adding a selected group of users to
<a name="INDEX-479" /> <a name="INDEX-480" />the
password file. The definitions and behavior of netgroups are
confusing because their syntax doesn't exactly match the way
the netgroup information is used. Even though the netgroup syntax
allows you to specify user and hostnames in the same triple, user and
hostnames are rarely used <em class="emphasis">together</em>. For example,
when a netgroup is used to add users to an NIS-managed password file,
only the usernames are taken from the netgroup. The hostnames are
ignored, because hostnames have no place in the password file.
Similarly, when using a netgroup to grant filesystem access
permissions to a set of NFS clients, only the hostname fields
<a name="INDEX-481" /> <a name="INDEX-482" />
<a name="INDEX-483" />in the netgroup are used.
Usernames are ignored in this case, which means a hostname will be
included in the list even if <tt class="literal">-</tt> is used as the
username in its triple.</p>


Some examples are helpful:</p>


<blockquote><pre class="code">source (-,stern,nesales), (-,julie,nesales), (-,peter,nesales) 
trusted-hosts (bitatron,,), (corvette,,) 
trusted-users (bitatron,stern,), (corvette,johnc,) 
dangerous-users (,jimc,), (,dave,)</pre></blockquote>


In the first example, <em class="emphasis">source</em> is a group
<a name="INDEX-484" />
<a name="INDEX-485" />of three users;
in this respect, the netgroup is similar to an entry in
<em class="emphasis">/etc/group</em>. The <em class="emphasis">source</em>
netgroup in this case grants no specific permissions, although it
could be included in the password file for the source archive
machine, granting selected users access to that host. The second
example shows a definition for a set of hosts, and would be of no use
in a password file. In the third example, <em class="emphasis">stern</em>
and <em class="emphasis">johnc</em> are members of the
<em class="emphasis">trusted-users</em> group when it is parsed for
usernames. Hosts <em class="emphasis">bitatron</em> and
<em class="emphasis">corvette</em> are members of
<em class="emphasis">trusted-users</em> when it is parsed for hostnames.
Note that there is no interpretation of the netgroup that associates
user <em class="emphasis">stern</em> with host
<em class="emphasis">bitatron</em>. In the fourth example,
<em class="emphasis">dave</em> and <em class="emphasis">jimc</em> are members
of <em class="emphasis">dangerous-users</em>, but no hosts are included in
this group. The domain name field is used when multiple NIS domains
exist on the same network and it is necessary to create a group that
is valid in only one or the other domain.</p>


These groups are very different from <a name="INDEX-486" />those in
<em class="emphasis">/etc/group</em>. The group file (or equivalent NIS
map) explicitly grants permissions to users while the netgroup
mechanism simply creates shorthand notations or nicknames. A netgroup
can be used in many places where a user or hostname would appear,
such as the password file or in the list of hosts that can access an
NFS filesystem.</p>


You can also build netgroups from <a name="INDEX-487" />other netgroups. For example, you
could create the netgroup <em class="emphasis">hosts-n-users</em> from the
following entry:</p>


<blockquote><pre class="code">hosts-n-users trusted-hosts, trusted-users</pre></blockquote>


This netgroup contains all the members of both
<em class="emphasis">trusted-hosts</em> and
<em class="emphasis">trusted-users</em>.</p>


By using netgroups carefully, you can create special-purpose groups
that can be managed separately. For example, you could create a group
of "administrators" that can easily be added to the
password list of every machine, or a group of "visitors"
who are only added to the password files of certain machines.</p>


A final note about netgroups: they are accessible
<em class="emphasis">only</em> through NIS. The library routines that have
been modified to use NIS maps have also been educated about the uses
of the netgroup map, and use the <em class="emphasis">netgroup</em>,
<em class="emphasis">password</em>, and <em class="emphasis">host</em> maps
together. If NIS is not running, netgroups are not defined. This
implies that any <em class="emphasis">netgroup</em> file on an NIS client
is ignored, because the NIS netgroup map replaces the local file. A
local netgroup file does nothing at all. The uses of netgroups will
be revisited as a <a name="INDEX-488" /> <a name="INDEX-489" />security mechanism.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.3" /><div class="sect2">
<h3 class="sect2">3.3.3. Hostname formats in netgroups</h3>


The previous section used nonfully <a name="INDEX-490" />
<a name="INDEX-491" />qualified hostnames, which are
hostnames without a domain name suffix. This is the norm when using
the <em class="emphasis">hosts</em> map in NIS to store hostnames. If you
have hostnames that are available only in DNS, then you can and must
use fully qualified hostnames in the <em class="emphasis">netgroup</em>
map if you want those hosts to be members of a particular netgroup.
See <a href="ch05_01.html">Chapter 5, "Living with Multiple Directory Servers "</a> for more details on <a name="INDEX-492" />running NIS and DNS
on the same network.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.4" /><div class="sect2">
<h3 class="sect2">3.3.4. Integrating NIS maps with local files</h3>


For files that are augmented by NIS maps, <a name="INDEX-493" /> <a name="INDEX-494" /> <a name="INDEX-495" />you
typically strip the local file to the minimum number of entries
needed for bootstrap or single-user operation. You then add in
entries that are valid only on the local host  --  for example, a
user with an account on only one machine  --  and then integrate
NIS services by adding special entries that refer to the NIS map
files.</p>


<a name="INDEX-496" />The
<em class="emphasis">/etc/nsswitch.conf</em> file is used to control how
NIS maps and local files are integrated. Normally if the two are
integrated, the file is interpreted first, followed by the NIS map.
For example, look at the <em class="emphasis">passwd</em> entry in the
default <em class="emphasis">nsswitch.conf</em> for NIS clients:</p>


<blockquote><pre class="code">passwd:     files nis</pre></blockquote>


The keyword <em class="emphasis">files</em> tells the system to read
<em class="emphasis">/etc/passwd</em> first, and if the desired entry is
not found, search <em class="emphasis">passwd.byname</em> or
<em class="emphasis">passwd.byuid</em>, depending on whether the system is
searching by account name or user identifier number. The reason why
the <em class="emphasis">passwd</em> file is examined before the NIS map
is that some accounts, such as <em class="emphasis">root</em>, are not
placed in NIS, for security reasons (see <a href="ch03_02.html#nfs2-CHP-3-SECT-2.2">Section 3.2.2, "Installing the NIS master server"</a> in this chapter). If NIS were searched
before the local <em class="emphasis">passwd</em> file, and if
<em class="emphasis">root</em> were in NIS, then there would effectively
be one global password for <em class="emphasis">root</em>. This is not
desirable, because once an attacker figured out the
<em class="emphasis">root</em> password for one system, he'd know
the <em class="emphasis">root</em> password for all systems. Or, even if
<em class="emphasis">root</em> were not in NIS, if clients were configured
to read NIS before files for <em class="emphasis">passwd</em> information,
the attacker that successfully compromised a NIS server, would be
able to insert a root entry in the <em class="emphasis">passwd</em> map
and gain access to every client.</p>



<a name="ch03-1615" /><blockquote><b>TIP: </b> 
The default files and NIS integration will have your clients getting
hostname and address information from NIS. Since you will likely have
DNS running, you will find it better to get host informaton from DNS.
See <a href="ch05_01.html">Chapter 5, "Living with Multiple Directory Servers "</a>.</p>

</blockquote>

At this point, we've run through most of what you need to know
to get NIS running. With this background out of the way, we'll
look at how NIS works. Along the way, we will give more precise
definitions of terms that, until now, we have been using fairly
loosely. Understanding how NIS works is essential to successful
debugging. It is also crucial to planning your NIS network.</p>


NIS is built on the RPC protocol, and uses the<a name="INDEX-497" /> UDP transport to move requests from the
client host to the server. NIS services are integrated into the
standard Unix library calls so that they remain transparent to
processes that reference NIS-managed files. If you have a process
that reads <em class="emphasis">/etc/passwd</em>, most of the queries
about that file will be handled by NIS RPC calls to an NIS server.
The library calling interface used by the application does not change
at all, but the implementations of library routines such as
<em class="emphasis">getpwuid</em>( ) that read the
<em class="emphasis">/etc/passwd</em> file are modified to refer to NIS or
to NIS and local files. The application using
<em class="emphasis">getpwuid</em>( ) is oblivious to the change in its
implementation.</p>


Therefore, when you enable NIS, you don't have
<a name="INDEX-498" />to change any existing software. A
vendor that supports NIS has already modified all of the relevant
library calls to have them make NIS RPC calls in addition to looking
at local files where relevant. Any process that used to do lookups in
the host table still works; <a name="INDEX-499" /> <a name="INDEX-500" /> <a name="INDEX-501" />it just does something different in the
depths of the library calls.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.5" /><div class="sect2">
<h3 class="sect2">3.3.5. Map files</h3>


Configuration files managed by NIS are <a name="INDEX-502" />converted
into keyword and value pair tables called <em class="emphasis">maps</em>.
We've been using the term "map" all along, as if a
map were equivalent to the ASCII files that it replaces or augments.
For example, we have said that the <em class="emphasis">passwd</em> NIS
map is appended to the NIS client's
<em class="emphasis">/etc/passwd</em> file. Now it's time to
understand what a map file really is.</p>


NIS maps are constructed <a name="INDEX-503" />
<a name="INDEX-504" />
<a name="INDEX-505" />from DBM database files. DBM is the
database system that is built into BSD Unix implementations; if it is
not normally shipped as part of your Unix system, your vendor will
supply it as part of the NIS implementation. Under DBM, a database
consists of a set of keys and associated values organized in a table
with fast lookup capabilities. Every key and value pair may be
located using at most two filesystem accesses, making DBM an
efficient storage mechanism for NIS maps. A common way to use the
password file, for example, is to locate an <a name="INDEX-506" />entry by user ID number, or UID. Using the
flat <em class="emphasis">/etc/passwd</em> file, a linear search is
required, while the same value can be retrieved from a DBM file with
a single lookup. This performance improvement in data location
offsets the overhead of performing a remote procedure call over the
network.</p>


Each DBM database, and therefore each NIS map,
<a name="INDEX-507" />
<a name="INDEX-508" />
<a name="INDEX-509" />
<a name="INDEX-510" /> <a name="INDEX-511" />comprises two files: a
hash-table accessed bitmap of indices and a data file. The index file
has the <em class="emphasis">.dir</em> extension and the data file uses
<em class="emphasis">.pag</em>. A database called
<em class="emphasis">addresses</em> would be stored in:</p>


<blockquote><pre class="code">addresses.dir        <i class="lineannotation">index file </i>
addresses.pag        <i class="lineannotation">data file</i></pre></blockquote>


A complete map contains both files.</p>


Consecutive records are not packed in the
<a name="INDEX-512" />data
file; they are arranged in hashed order and may have empty blocks
between them. As a result, the DBM data file may appear to be up to
four times as large as the data that it contains. The Unix operating
system allows a file to have holes in it that are created when the
file's write pointer is advanced beyond the end of the file
<a name="INDEX-513" />using
<em class="emphasis">lseek</em>( ). Filesystem data blocks are allocated
only for those parts of the file containing data. The empty blocks
are not allocated, and the file is only as large as the total number
of used filesystem blocks and fragments.</p>


The holes in DBM files make them difficult
<a name="INDEX-514" />
<a name="INDEX-515" />
<a name="INDEX-516" />
<a name="INDEX-517" />to
manipulate using standard Unix utilities. If you try to copy an NIS
map using <em class="emphasis">cp</em>, or move it across a filesystem
<a name="INDEX-518" />
<a name="INDEX-519" />
<a name="INDEX-520" />
<a name="INDEX-521" />boundary
with <em class="emphasis">mv</em>, the new file will have the holes
expanded into zero-filled disk blocks. When <em class="emphasis">cp</em>
reads the file, it doesn't expect to find holes, so it reads
sequentially from the first byte until the end-of-file is found.
Blocks that are not allocated are read back as zeros, and written to
the new file as all zeros as well. This has the unfortunate side
effect of making the copied DBM files consume much more disk space
than the hole-filled files. Furthermore, NIS maps will not be usable
on a machine of another architecture: if you build your maps on a
SPARC machine, you can't copy them to an Intel-based machine.
Map files are not ASCII files. For the administrator, the practical
consequence is that you must always use NIS tools (like
<em class="emphasis">ypxfr</em> and <em class="emphasis">yppush</em>, discussed
in <a href="ch04_02.html#nfs2-CHP-4-SECT-2.1">Section 4.2.1, "Map distribution"</a>) to move maps from one machine to
another.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.6" /><div class="sect2">
<h3 class="sect2">3.3.6. Map naming</h3>


ASCII files are converted into DBM files by selecting
<a name="INDEX-522" />
<a name="INDEX-523" /> <a name="INDEX-524" />the key <a name="INDEX-525" />
<a name="INDEX-526" />field
and separating it from the value field by spaces or a tab. The
<em class="emphasis">makedbm</em> utility <a name="INDEX-527" />
<a name="INDEX-528" />builds
the <em class="emphasis">.dir</em> <a name="INDEX-529" />and <em class="emphasis">.pag</em> files
<a name="INDEX-530" />from ASCII input files. A limitation of
the DBM system is that it supports only one key per value, so files
that are accessed by more than one field value require an NIS map for
each key field. With a flat ASCII file, you can read the records
sequentially and perform comparisons on any field in the record.
However, DBM files are indexed databases, so only one field  -- 
the key  --  is used for comparisons. If you need to search the
database in two different ways, using two fields, then you must use
two NIS maps or must implement one of the searches as a linear walk
through all of the records in the NIS map.</p>


The password file is a good example of an ASCII file that is searched
on multiple fields. The <em class="emphasis">getpwnam</em>( ) library call
opens the <a name="INDEX-531" />
<a name="INDEX-532" />password file
and looks for the entry for a specific username. Equal in popularity
is the <em class="emphasis">getpwuid</em>( ) library routine, which
searches the database looking for the given user ID value. While
<em class="emphasis">getpwnam</em>( ) is used by
<em class="emphasis">login</em> and <em class="emphasis">chown</em>,
<em class="emphasis">getpwuid</em>( ) is used by processes that need to
match numeric user ID values to names, such as <em class="emphasis">ls
-l</em>. To accommodate both access methods, the standard set
of NIS maps includes two maps derived from the password file: one
that uses the username as a key and one that uses the user ID field
as a key.</p>


The map names used by NIS indicate the source
<a name="INDEX-533" />
<a name="INDEX-534" />
<a name="INDEX-535" />of the data and the key field. The
convention for map naming is:</p>


<a name="INDEX-536" /><a name="INDEX-537" /><blockquote><pre class="code">filename.bykeyname</pre></blockquote>


The two NIS maps generated
<a name="INDEX-538" /> <a name="INDEX-539" />from the password file, for
example, are <em class="emphasis">passwd.byname</em> (used by
<em class="emphasis">getpwnam</em>( )) and
<em class="emphasis">passwd.byuid</em> (used by
<em class="emphasis">getpwuid</em>( )). These two maps are stored on disk
as four files:</p>


<blockquote><pre class="code">passwd.byname.dir 
passwd.byname.pag 
passwd.byuid.dir 
passwd.byuid.pag</pre></blockquote>


The order of the records in the maps will be different because they
have different key fields driving the hash algorithm, but they
contain exactly <a name="INDEX-540" /> <a name="INDEX-541" />the same sets of entries.</p>
</div>




<a name="nfs2-CHP-3-SECT-3.7" /><div class="sect2">
<h3 class="sect2">3.3.7. Map structure</h3>


Two extra entries are added to each NIS map by
<em class="emphasis">makedbm</em>. The <a name="INDEX-542" />master
server name for the map is embedded in one entry and the map's
<em class="emphasis">order</em>,
or<a name="INDEX-543" />
<a name="INDEX-544" /> <a name="INDEX-545" /> modification timestamp, is put
in the other. These additional entries allow the map to describe
itself fully, without requiring NIS to keep map management data.
Again, NIS is ignorant of the content of the maps and merely provides
an access mechanism. The maps themselves must contain timestamp and
ownership information to coordinate updates with the master NIS
server.</p>


Some maps are given nicknames based on the
<a name="INDEX-546" />
<a name="INDEX-547" /><a name="INDEX-548" /> <a name="INDEX-549" />original file from which they are
derived. Map nicknames exist only within the
<em class="emphasis">ypwhich</em> and <em class="emphasis">ypmatch</em>
utilities (see <a href="ch13_04.html#nfs2-CHP-13-SECT-4">Section 13.4, "NIS tools"</a>) that retrieve information
from NIS maps. Nicknames are neither part of the NIS service nor
embedded in the maps themselves. They do provide convenient
shorthands for referring to popular maps such as the
<a name="INDEX-550" />
<a name="INDEX-551" />password
or hosts files. For example, the map nickname
<em class="emphasis">passwd</em> refers to the
<em class="emphasis">passwd.byname</em> map, and the
<em class="emphasis">hosts</em> nickname refers to the
<em class="emphasis">hosts.byname</em> map. To locate the password file
entry for user <em class="emphasis">stern</em> in the
<em class="emphasis">passwd.byname</em> map, use
<em class="emphasis">ypmatch</em> with the map nickname:</p>


<blockquote><pre class="code">% <tt class="userinput"><b>ypmatch stern passwd</b></tt> 
stern:passwd:1461:10:Hal Stern:/home/thud/stern:/bin/csh</pre></blockquote>


In this example, <em class="emphasis">ypmatch</em> expands the nickname
<em class="emphasis">passwd</em> to the map name
<em class="emphasis">passwd.byname</em>, locates the key
<em class="emphasis">stern</em> in that map, and prints the data value
associated with the key.</p>


The library routines that use NIS don't retain any information
from the maps. Once a routine looks up a hostname, for example, it
passes the data back to the caller and "forgets"
about<a name="INDEX-552" /> the
transaction. On Solaris, if the name service cache daemon (nscd) is
running, then the results of queries from the passwd, group, and
hosts maps are cached in the nscd daemon. Subsequent queries for the
same entry will be satisfied out of the cache. The cache will keep
the result of an NIS query until the entry reaches its time to live
(ttl) threshold. Each cached NIS map has different time to live
values. You can invoke nscd with the -g option to see what the time
to live values are.
<a name="INDEX-553" /> <a name="INDEX-554" /> <a name="INDEX-555" /></p>
</div>




<a name="nfs2-CHP-3-SECT-3.8" /><div class="sect2">
<h3 class="sect2">3.3.8. NIS domains</h3>


"Domain" is another term that we have
<a name="INDEX-556" />used loosely; <a name="INDEX-557" />now
we'll <a name="INDEX-558" />define
domains more precisely. Groups of hosts that use the same set of maps
form an NIS <em class="emphasis">domain</em>. All of the machines in an
NIS domain will share the same password, hosts, and group file
information. Technically, the maps themselves are grouped together to
form a domain, and hosts join one or more of these NIS domains. For
all practical purposes, though, an NIS domain includes both a set of
maps and the machines using information in those map files.</p>


NIS domains define spheres of system management. A domain is a name
applied to a group of NIS maps. The hosts that need to look up
information in the
<a name="INDEX-559" />
<a name="INDEX-560" />maps <em class="emphasis">bind</em>
themselves to the domain, which involves finding an NIS server that
has the maps comprising the domain. It's easy to refer to the
hosts that share a set of maps and the set of maps themselves
interchangeably as a domain. The important point is that NIS domains
are <em class="emphasis">not</em> just defined as a group of hosts; NIS
domains are defined around a set of maps and the hosts that use these
map files. Think of setting up NIS domains as
<a name="INDEX-561" />building a set of database
definitions. You need to define both the contents of the database and
the users or hosts that can access the data in it. When defining NIS
domains, you must decide if the data in the NIS maps applies to all
hosts in the domain. If not, you may need to define multiple domains.
This is equivalent to deciding that you really need two or more
groups of databases to meet the requirements of different groups of
users and hosts.</p>


<a name="INDEX-562" />
<a name="INDEX-563" />As
we've seen, the default domain name for a host is set
<a name="INDEX-564" />
<a name="INDEX-565" />using
the <em class="emphasis">domainname</em> command:</p>


<blockquote><pre class="code">nisclient# <tt class="userinput"><b>domainname nesales</b></tt></pre></blockquote>


This usually appears in the boot scripts as:</p>


<blockquote><pre class="code">/usr/bin/domainname `cat /etc/defaultdomain`</pre></blockquote>


Only the superuser can set or
<a name="INDEX-566" />
<a name="INDEX-567" />change the default domain. Without an
argument, <em class="emphasis">domainname</em> prints the currently set
domain name. Library calls that use NIS always request maps from the
default domain, so setting the domain name must be the first step in
NIS startup. It is possible for an application to request map
information from more than one domain, but assume for now that all
requests refer to maps in the current default domain.</p>


Despite the long introduction, a domain is implemented as nothing
more than a subdirectory of the top-level NIS directory,
<em class="emphasis">/var/yp.</em> Nothing special is required to create a
new domain  --  you simply assign it a name and then put maps into
it using the server initialization procedures described later. The
map files for a domain are placed in its subdirectory:</p>


<blockquote><pre class="code">/var/yp/domainname/mapname</pre></blockquote>


You can create multiple domains by
repeating<a name="INDEX-568" /> the initialization using different
NIS domain names. Each new domain initialization creates a new
subdirectory in the NIS map directory <em class="emphasis">/var/yp</em>.
An NIS server provides service for every domain represented by a
subdirectory in <em class="emphasis">/var/yp</em>. If multiple
subdirectories exist, the NIS server answers binding requests for all
of them. You do not have to tell NIS which domains to serve
explicitly  --  it figures this out by looking at the structure of
its map directory.</p>


It's possible to treat NIS as another administrative tool.
However, it's more flexible than a simple configuration file
management system. NIS resembles a database management system with
multiple tables. As long as the NIS server can locate map information
with well-known file naming and key lookup conventions, the contents
of the map files are immaterial to the server. A relational database
system such as Oracle provides the framework of schemas and views,
but it doesn't care what the schemas look like or what data is
in the tables. Similarly, the NIS system provides a framework for
locating information in map files, but the information in the files
and the existence or lack of map files themselves is not of
consequence to the NIS server. There is no minimal set of map files
necessary to define a domain. While this places the responsibility
for map synchronization on the system manager, it also affords the
flexibility of adding locally defined maps to the system that are
managed and accessed in a well-known manner.</p>


<a name="nfs2-CHP-3-SECT-3.8.1" /><div class="sect3">
<h3 class="sect3">3.3.8.1. Internet domains versus NIS domains</h3>


The term "domain" is used in different ways by
<a name="INDEX-569" />
<a name="INDEX-570" />different services. In the Internet
community, a domain refers to a group of hosts that are managed
<a name="INDEX-571" />
<a name="INDEX-572" />by an Internet Domain Name Service.
These domains are defined strictly in terms of a group of hosts under
common management, and are tied to organizations and their
hierarchies. These domains include entire corporations or divisions,
and may encompass several logical TCP/IP networks. The Internet
domain <em class="emphasis">east.sun.com</em>, for example, spans six
organizations spread over at least 15 states.</p>


Domains in the NIS world differ from Internet name service domains in
several ways. NIS domains exist only in the scheme of local network
management and are usually driven by physical limits or political
"machine ownership" issues. There may be several NIS
domains on one network, all managed by the same system administrator.
Again, it is the set of maps and the hosts that use the maps that
define an NIS domain, rather than a particular network partitioning.
In general, you may find many NIS domains in an Internet name service
domain; the name service's hostname database is built from the
hostname maps in the individual NIS domains. Integration of NIS and
name services is covered in <a href="ch05_01.html#nfs2-CHP-5-SECT-1">Section 5.1, "Domain name servers"</a>. From here
on, "domain" refers to an NIS domain unless explicitly
<a name="INDEX-573" />noted.
<a name="INDEX-574" /></p>
</div>
</div>




<a name="nfs2-CHP-3-SECT-3.9" /><div class="sect2">
<h3 class="sect2">3.3.9. The ypserv daemon</h3>


NIS service is provided<a name="INDEX-575" />
<a name="INDEX-576" />
by a single daemon, <em class="emphasis">ypserv</em>, that handles all
client requests. It's simple to tell whether a system is an NIS
server: just look to see whether <em class="emphasis">ypserv</em> is
running. In this section we'll look at the RPC procedures
implemented as part of the NIS protocol and the facilities used to
transfer maps from master to slave servers.</p>


<a name="INDEX-577" /><a name="INDEX-578" /><a name="INDEX-579" /><a name="INDEX-580" />Three sets of procedure
calls<a name="INDEX-581" />
<a name="INDEX-582" /> <a name="INDEX-583" /> make up the NIS protocol:
client lookups, map maintenance calls, and NIS internal calls. Lookup
requests are key-driven, and return one record from the DBM file per
call. There are four kinds of lookups: match (single key), get-first,
get-next, and get-all records. The get-first and get-next requests
<a name="INDEX-584" />
<a name="INDEX-585" />are used to
scan the NIS map linearly, although keys are returned in a random
order. "First" refers to the first key encountered in the
data file based on hash table ordering, not the first key from the
ASCII source file placed into the map.</p>


Map maintenance calls are used<a name="INDEX-586" />
<a name="INDEX-587" />
<a name="INDEX-588" /> when
negotiating a map transfer between master and slave servers, although
they may be made by user applications as well. The get-master
function returns the master server for a map and the get-order
request returns the timestamp from the last generation of the map
file. Both values are available as records in the NIS maps. Finally,
the NIS internal calls are used to effect a map transfer and answer
requests for service to a domain. An NIS server replies only
positively to a service request; if it cannot serve the named domain
it will not send a reply.</p>


The server daemon does not have any intrinsic knowledge of what
domains it serves or which maps are available in those domains. It
answers a request for service if the domain has a subdirectory in the
NIS server directory. That is, a request for
service<a name="INDEX-589" /> to domain
<em class="emphasis">polygon</em> will be answered if the
<em class="emphasis">/var/yp/polygon</em> directory exists. This directory
may be empty, or may not contain a full complement of maps, but the
server still answers a service request if the map directory exists.
There is no NIS RPC procedure to inquire about the existence of a map
on a server; a "no such map" error is returned on a
failed lookup request for the missing map. This underscores the need
for every NIS server to have a full set of map files  --  the NIS
mechanism itself can't tell when a map is missing until an NIS
client asks for information from it.</p>


If the log file <em class="emphasis">/var/yp/ypserv.log</em> exists when
<em class="emphasis">ypserv</em> is started, error and warning messages
will be written to this file. If an NIS server receives a service
request for a domain it cannot serve, it logs messages such as:</p>


<blockquote><pre class="code">ypserv: Domain financials not supported (broadcast)</pre></blockquote>


indicating that it ignored a broadcast request for an unknown domain.
If each server handles only its default domain, binding attempts
overheard from other domains generate large numbers of these log
messages. Running multiple NIS domains on a single IP network is best
done if every server can handle every domain, or if you turn off
logging. If not, you will be overwhelmed with these informational
error messages that do nothing but grow the log file.</p>


<em class="emphasis">ypserv</em> keeps the file open while it is running,
so a large log file must be cleaned up by truncating it:</p>


<blockquote><pre class="code"># <tt class="userinput"><b>cat /dev/null &gt; /var/yp/ypserv.log</b></tt></pre></blockquote>


Removing the file with <em class="emphasis">rm</em> clears the directory
entry, but does not free the disk space because the
<em class="emphasis">ypserv</em> process still has the file open. If you
have multiple domains with distinct servers on a single network, you
probably shouldn't enable <a name="INDEX-590" /> <a name="INDEX-591" />NIS logging.
<a name="INDEX-592" /></p>
</div>




<a name="nfs2-CHP-3-SECT-3.10" /><div class="sect2">
<h3 class="sect2">3.3.10. The ypbind daemon</h3>


The <em class="emphasis">ypbind</em> daemon is central to NIS client
operation. <a name="INDEX-593" />
<a name="INDEX-594" />Whenever
any system is running <em class="emphasis">ypbind</em>, it is an NIS
client  --  no matter what else it is doing. Therefore, it will be
worth our effort to spend some time thinking about
<em class="emphasis">ypbind</em>.</p>


When <em class="emphasis">ypbind</em> first starts, it finds a server for
the host's default domain. The process of locating a server is
<a name="INDEX-595" /> <a name="INDEX-596" />
<a name="INDEX-597" />called
<em class="emphasis">binding</em> the domain. If processes request service
from other domains, <em class="emphasis">ypbind</em> attempts to locate
servers for them as needed. <em class="emphasis">ypbind</em> reads a file
like <em class="emphasis">/var/yp/binding/bedrock/ypservers</em> to get
the name of an NIS server to bind to. If the NIS server chosen for a
domain crashes or begins to respond slowly due to a high load,
<em class="emphasis">ypbind</em> selects the next NIS server in the
<em class="emphasis">ypservers</em> file to re-bind. The NIS timeout
period varies by implementation, but is usually between two and three
minutes. Each client can be bound to several domains at once;
<em class="emphasis">ypbind</em> manages these bindings and locates
servers on demand for each newly referenced NIS domain.</p>


A client in the NIS server-client relationship is not just a host,
but a process on that host that needs NIS map information. Every
client process must be bound to a server, and they do so by asking
<em class="emphasis">ypbind</em> to locate a server on their behalf.
<em class="emphasis">ypbind</em> keeps track of the server to which it is
currently directing requests, so new client binding requests can be
answered without having to contact an NIS server.
<em class="emphasis">ypbind</em> continues to use its current server until
it is explicitly told, as the result of an NIS RPC timeout, that the
current server is not providing prompt service. After an RPC timeout,
<em class="emphasis">ypbind</em> will try the next server in the
<em class="emphasis">ypservers</em> file in an attempt to locate a faster
NIS server. Because all client processes go through
<em class="emphasis">ypbind</em>, we usually don't make a
distinction between the client processes and the host on which they
are running  --  the host itself is called the NIS client.</p>


Once <em class="emphasis">ypbind</em> has created a binding between a
client and a server, it never talks to the server again. When a
client process requests a binding, <em class="emphasis">ypbind</em> simply
hands back the name of the server to which the queries should be
directed. Once a process has bound to a server, it can use that
binding until an error occurs (such as a server crash or failure to
respond). A process does <em class="emphasis">not</em> bind its domain
before each NIS RPC call.</p>


Domain bindings are shown by <em class="emphasis">ypwhich</em>:</p>


<blockquote><pre class="code">% <tt class="userinput"><b>domainname</b></tt> 
nesales 
% <tt class="userinput"><b>ypwhich</b></tt> 
wahoo</pre></blockquote>


Here, <em class="emphasis">ypwhich</em> reports the currently bound server
for the named domain. If the default or the named domain is not
bound, <em class="emphasis">ypwhich</em> reports an error:</p>


<blockquote><pre class="code">gonzo% <tt class="userinput"><b>ypwhich -d financials</b></tt> 
Domain financials not bound on gonzo</pre></blockquote>


An NIS client can be put back in standalone operation <a name="INDEX-598" /> <a name="INDEX-599" />by modifying
<em class="emphasis">/etc/nsswitch.conf:</em></p>


<blockquote><pre class="code">client# <tt class="userinput"><b>cp /etc/nsswitch.files /etc/nsswitch.conf</b></tt></pre></blockquote>
</div>




<a name="nfs2-CHP-3-SECT-3.11" /><div class="sect2">
<h3 class="sect2">3.3.11. NIS server as an NIS client</h3>


Previously, we recommended that NIS
<a name="INDEX-600" />servers
<a name="INDEX-601" />
<a name="INDEX-602" />
<a name="INDEX-603" />also be NIS clients. This has a number
of important effects on the network's behavior. When NIS
servers are booted, they may bind to each other instead of to
themselves. A server that is booting executes a sequence of commands
that keep it fairly busy; so the local ypbind process may timeout
trying to bind to the local NIS server, and bind successfully with
another host. Thus multiple NIS servers usually end up cross-binding
 --  they bind to each other instead of themselves.</p>


If servers are also NIS clients, then having only one master and one
slave server creates a window in which the entire network pauses if
either server goes down. If the servers have bound to each other, and
one crashes, the other server rebinds to itself after a short
timeout. In the interim, however, the "live" server is
probably not doing useful work because it's waiting for an NIS
server to respond. Increasing the number of slave servers decreases
the probability that a single server crash hangs other NIS servers
and consequently hangs their bound clients. In addition, running more
than two NIS servers prevents all NIS clients from rebinding to the
same server when an NIS server <a name="INDEX-604" /> <a name="INDEX-605" />becomes unavailable.</p>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch03_02.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch03_04.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">3.2. Basics of NIS management</td><td align="center" valign="top" width="228"><a href="index/index.html"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">3.4. Trace of a key match</td></tr></table><div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.html">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,84,90" href="../index.html" /><area shape="rect" coords="86,-7,176,90" href="../ssh/index.html" /><area shape="rect" coords="178,0,265,101" href="../tcp/index.html" /><area shape="rect" coords="266,0,333,90" href="index.html" /><area shape="rect" coords="334,-1,429,93" href="../snmp/index.html" /><area shape="rect" coords="431,0,529,116" href="../tshoot/index.html" /><area shape="rect" coords="534,0,594,104" href="../dns/index.html" /><area shape="rect" coords="595,1,704,108" href="../fire/index-2.html" /></map>

</body>
<!-- Mirrored from nnc3.com/mags/Networking2/nfs/ch03_03.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:39 GMT -->
</html>