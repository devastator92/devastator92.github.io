<html>
<!-- Mirrored from nnc3.com/mags/Networking2/tshoot/ch05_04.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:57:03 GMT -->
<head><title>tcpdump (Network Troubleshooting Tools)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Joseph D. Sloan" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="059600186XL" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Network Troubleshooting Tools" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.html" alt="Network Troubleshooting Tools" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.html" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch05_03.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"></a></td><td align="right" valign="top" width="228"><a href="ch05_05.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table><div>



<h2 class="sect1">5.4. tcpdump</h2>

<a name="INDEX-960" /><a name="INDEX-961" /><a name="INDEX-962" />The
<em class="filename">tcpdump</em> program was developed at the Lawrence
Berkeley Laboratory at the University of California, Berkeley, by Van
Jacobson, Craig Leres, and Steven McCanne. It was originally
developed to analyze TCP/IP performance problems. A number of
features have been added over time although some options may not be
available with every implementation. The program has been ported to a
wide variety of systems and comes preinstalled on many systems.
</p>

<a name="INDEX-963" /><a name="INDEX-964" /><a name="INDEX-965" />For a variety of reasons,
<em class="filename">tcpdump</em> is an ideal tool to begin with. It is
freely available, runs on many Unix platforms, and has even been
ported to Microsoft Windows. Features of its syntax and its file
format have been used or supported by a large number of subsequent
programs. In particular, its capture software,
<em class="filename">libpcap</em>, is frequently used by other capture
programs. Even when proprietary programs with additional features
exist, the universality of<em class="filename"> tcpdump</em> makes it a
compelling choice. If you work with a wide variety of platforms,
being able to use the same program on all or most of the platforms
can easily outweigh small advantages proprietary programs might have.
This is particularly true if you use the programs on an irregular
basis or don't otherwise have time to fully master them. It is
better to know a single program well than several programs
superficially. In such situations, special features of other programs
will likely go unused.
</p>

<a name="INDEX-966" />Since <em class="filename">tcpdump</em> is text
based, it is easy to run remotely using a Telnet connection. Its
biggest disadvantage is a lack of analysis, but you can easily
capture traffic, move it to your local machine, and analyze it with a
tool like <em class="filename">ethereal</em>. Typically, I use
<em class="filename">tcpdump</em> in text-only environments or on remote
computers. I use <em class="filename">ethereal</em> in a Microsoft Windows
or X Window environment and to analyze <em class="filename">tcpdump</em>
files.
</p>

<a name="nettroubletools-CHP-5-SECT-4.1" /><div class="sect2">
<h3 class="sect2">5.4.1. Using tcpdump</h3>

<a name="INDEX-967" />The simplest
way to run <em class="filename">tcpdump</em> is interactively by simply
typing the program's name. The output will appear on your
screen. You can terminate the program by typing Ctrl-C. But unless
you have an idle network, you are likely to be overwhelmed by the
amount of traffic you capture. What you are interested in will likely
scroll off your screen before you have a chance to read it.
</p>

Fortunately, there are better ways to run
<em class="filename">tcpdump</em>. The first question is how you plan to
use <em class="filename">tcpdump.</em> Issues include whether you also
plan to use the host on which <em class="filename">tcpdump</em> is running
to generate traffic in addition to capturing traffic, how much
traffic you expect to capture, and how you will determine that the
traffic you need has been captured.
</p>

<a name="INDEX-968" /><a name="INDEX-969" /><a name="INDEX-970" /><a name="INDEX-971" />There are several very simple, standard
ways around the problem of being overwhelmed by data. The Unix
commands <em class="filename">tee </em>and <em class="filename">script</em> are
commonly used to allow a user to both view and record output from a
Unix session. (Both <em class="filename">tee</em> and
<em class="filename">script</em> are described in <a href="ch11_01.html">Chapter 11, "Miscellaneous Tools"</a>.) For example, <em class="filename">script</em>
could be started, <em class="filename">tcpdump</em> run, and
<em class="filename">script</em> stopped to leave a file that could be
examined later.
</p>

<a name="INDEX-972" />The
<em class="filename">tee</em> command is slightly more complicated since
<em class="filename">tcpdump</em> must be placed in line mode to display
output with <em class="filename">tee</em>. This is done with the
<em class="filename">-l</em> option. The syntax for capturing a file with
<em class="filename">tee</em> is:
</p>

<blockquote><pre class="code">bsd1# tcpdump -l  | tee outfile</pre></blockquote>

Of course, additional arguments would probably be used.</p>

<a name="INDEX-973" /><a name="INDEX-974" />Using multiple Telnet connections to
a host or multiple windows in an X Window session allows you to
record in one window while taking actions to generate traffic in
another window. This approach can be very helpful in some
circumstances.
</p>

<a name="INDEX-975" />An alternative
is to use <em class="filename">telnet</em> to connect to the probe
computer. The session could be logged with many of the versions of
<em class="filename">telnet</em> that are available. Be aware, however,
that the Telnet connection will generate considerable traffic that
may become part of your log file unless you are using filtering.
(Filtering, which is discussed later in this chapter, allows you to
specify the type of traffic you want to examine.) The additional
traffic may also overload the connection, resulting in lost packets.
</p>

Another alternative is to run <em class="filename">tcpdump</em> as a
detached process by including an <em class="filename">&amp;</em> at the
end of the command line. Here is an
example:<a name="INDEX-976" />
</p>

<blockquote><pre class="code">bsd1# tcpdump -w outfile &amp;
[1] 70260
bsd1# tcpdump: listening on xl0</pre></blockquote>

The command starts <em class="filename">tcpdump</em>, prints a process
number, and returns the user prompt along with a message that
<em class="filename">tcpdump</em> has started. You can now enter commands
to generate the traffic you are interested in. (You really have a
prompt at this point; the message from <em class="filename">tcpdump</em>
just obscures it.) Once you have generated the traffic of interest,
you can terminate <em class="filename">tcpdump</em> by issuing a
<em class="filename">kill</em> command using the process number reported
when <em class="filename">tcpdump</em> was started. (You can use the
<em class="filename">ps</em> command if you have forgotten the process
number.)
</p>

<blockquote><pre class="code">bsd1# kill 70260
153 packets received by filter
0 packets dropped by kernel
[1]    Done                   tcpdump -w outfile</pre></blockquote>

<a name="INDEX-977" /><a name="INDEX-978" /><a name="INDEX-979" /><a name="INDEX-980" />You can now analyze the capture file.
(Running <em class="filename">tcpdump</em> as a detached process can also
be useful when you are trying to capture traffic that might not show
up for a while, e.g., RADIUS or DNS exchanges. You might want to use
the <em class="filename">nohup</em> command to run it in the background.)
</p>

<a name="INDEX-981" /><a name="INDEX-982" /><a name="INDEX-983" /><a name="INDEX-984" />Yet
another approach is to use the <em class="filename">-w</em> option to
write the captured data directly to a file. This option has the
advantage of collecting raw data in binary format. The data can then
be replayed with <em class="filename">tcpdump</em> using the
<em class="filename">-r</em> option. The binary format decreases the
amount of storage needed, and different filters can be applied to the
file without having to recapture the traffic. Using previously
captured traffic is an excellent way of fine-tuning filters to be
sure they work as you expect. Of course, you can selectively analyze
data captured as text files in Unix by using the many tools Unix
provides, but you can't use <em class="filename">tcpdump</em>
filtering on text files. And you can always generate a text file from
a <em class="filename">tcpdump</em> file for subsequent analysis with Unix
tools by simply redirecting the output. To capture data you might
type:
</p>

<blockquote><pre class="code">bsd1# tcpdump -w rawfile</pre></blockquote>

The data could be converted to a text file with:</p>

<blockquote><pre class="code">bsd1# tcpdump -r rawfile   &gt; textfile</pre></blockquote>

This approach has several limitations. Because the data is being
written directly to a file, you must know when to terminate recording
without actually seeing the traffic. Also, if you limit what is
captured with the original run, the data you exclude is lost. For
these reasons, you will probably want to be very liberal in what you
capture, offsetting some of the storage gains of the binary format.
Clearly, each approach has its combination of advantages and
disadvantages. If you use <em class="filename">tcpdump</em> very much, you
will probably need each from time to time.<a name="INDEX-985" />
</p>

</div>
<a name="nettroubletools-CHP-5-SECT-4.2" /><div class="sect2">
<h3 class="sect2">5.4.2. tcpdump Options</h3>

<a name="INDEX-986" />A number of command-line options are
available with <em class="filename">tcpdump</em>. Roughly speaking,
options can be separated into four broad categories -- commands
that control the program operations (excluding filtering), commands
that control how data is displayed, commands that control what data
is displayed, and filtering commands. We will consider each category
in turn.
</p>

<a name="nettroubletools-CHP-5-SECT-4.2.1" /><div class="sect3">
<h3 class="sect3">5.4.2.1. Controlling program behavior</h3>

<a name="INDEX-987" /><a name="INDEX-988" /><a name="INDEX-989" /><a name="INDEX-990" /><a name="INDEX-991" /><a name="INDEX-992" /><a name="INDEX-993" /><a name="INDEX-994" />This class of command-line options
affects program behavior, including the way data is collected. We
have already seen two examples of control commands,
<em class="filename">-r</em> and <em class="filename">-w</em>. The
<em class="filename">-w</em> option allows us to redirect output to a file
for later analysis, which can be extremely helpful if you are not
sure exactly how you want to analyze your data. You can subsequently
play back capture data using the <em class="filename">-r</em> option. You
can repeatedly apply different display options or filters to the data
until you have found exactly the information you want. These options
are extremely helpful in learning to use <em class="filename">tcpdump</em>
and are essential for documentation and sharing.
</p>

<a name="INDEX-995" />If you know how many packets you want
to capture or if you just have an upper limit on the number of
packets, the <em class="filename">-c</em> option allows you to specify
that number. The program will terminate automatically when that
number is reached, eliminating the need to use a
<em class="filename">kill</em> command or Ctrl-C. In the next example,
<em class="filename">tcpdump</em> will terminate after 100 packets are
collected:
</p>

<blockquote><pre class="code">bsd1# tcpdump -c100</pre></blockquote>

While limiting packet capture can be useful in some circumstances, it
is generally difficult to predict accurately how many packets need to
be collected.
</p>

<a name="INDEX-996" /><a name="INDEX-997" />If
you are running <em class="filename">tcpdump</em> on a host with more than
one network interface, you can specify which interface you want to
use with the <em class="filename">-i</em> option. Use the command
<em class="filename">ifconfig -a</em> to discover what interfaces are
available and what networks they correspond to if you aren't
sure. For example, suppose you are using a computer with two class C
interfaces, <em class="filename">xl0</em> with an IP address of
<em class="filename">205.153.63.238</em> and <em class="filename">xl1</em> with
an IP address of <em class="filename">205.153.61.178</em>. Then, to
capture traffic on the <em class="filename">205.153.61.0</em> network, you
would use the command:
</p>

<blockquote><pre class="code">bsd1# tcpdump -i xl1</pre></blockquote>

Without an explicitly identified interface,
<em class="filename">tcpdump</em> defaults to the lowest numbered
interface.
</p>

<a name="INDEX-998" /><a name="INDEX-999" />The <em class="filename">-p</em> option
says that the interface should not be put into promiscuous mode. This
option would, in theory, limit capture to the normal traffic on the
interface -- traffic to or from the host, multicast traffic, and
broadcast traffic. In practice, the interface might be in promiscuous
mode for some other reason. In this event, <em class="filename">-p</em>
will not turn promiscuous mode off.
</p>

<a name="INDEX-1000" /><a name="INDEX-1001" />Finally,
<em class="filename">-s</em> controls the amount of data captured.
Normally, <em class="filename">tcpdump</em> defaults to some maximum byte
count and will only capture up to that number of bytes from
individual packets. The actual number of bytes depends on the
pseudodevice driver used by the operating system. The default is
selected to capture appropriate headers, but not to collect packet
data unnecessarily. By limiting the number of bytes collected,
privacy can be improved. Limiting the number of bytes collected also
decreases processing and buffering requirements.
</p>

<a name="INDEX-1002" />If
you need to collect more data, the <em class="filename">-s</em> option can
be used to specify the number of bytes to collect. If you are
dropping packets and can get by with fewer bytes,
<em class="filename">-s</em> can be used to decrease the number of bytes
collected. The following command will collect the entire packet if
its length is less than or equal to 200 bytes:
</p>

<blockquote><pre class="code">bsd1# tcpdump -s200</pre></blockquote>

<a name="INDEX-1003" /><a name="INDEX-1004" /><a name="INDEX-1005" />Longer packets will be truncated to
200 bytes.
</p>

If you are capturing files using the <em class="filename">-w</em> option,
you should be aware that the number of bytes collected will be what
is specified by the <em class="filename">-s</em> option at the time of
capture. The <em class="filename">-s</em> option does not apply to files
read back with the <em class="filename">-r</em> option. Whatever you
captured is what you have. If it was too few bytes, then you will
have to recapture the data.
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.2" /><div class="sect3">
<h3 class="sect3">5.4.2.2. Controlling how information is displayed </h3>

<a name="INDEX-1006" /><a name="INDEX-1007" /><a name="INDEX-1008" /><a name="INDEX-1009" />The <em class="filename">-a</em>,
<em class="filename">-n,</em> <em class="filename">-N</em>, and
<em class="filename">-f</em> options determine how address information is
displayed. The <em class="filename">-a</em> option attempts to force
network addresses into names, the <em class="filename">-n</em> option
prevents the conversion of addresses into names, the
<em class="filename">-N</em> option prevents domain name qualification,
and the <em class="filename">-f</em> option prevents remote name
resolution. In the following, the remote site
<em class="filename">www.cisco.com</em>
(<em class="filename">192.31.7.130</em>) is pinged from
<em class="filename">sloan.lander.edu</em>
(<em class="filename">205.153.63.30</em>) without an option, with
<em class="filename">-a</em>, with <em class="filename">-n</em>, with
<em class="filename">-N,</em> and with <em class="filename">-f,</em>
respectively. (The options <em class="filename">-c1 host 192.31.7.130</em>
restricts capture to one packet to or from the host
<em class="filename">192.31.7.130</em>.) 
</p>

<blockquote><pre class="code">bsd1# tcpdump -c1 host 192.31.7.130
tcpdump: listening on xl0
14:16:35.897342 sloan.lander.edu &gt; cio-sys.cisco.com: icmp: echo request
bsd1# tcpdump -c1 -a host 192.31.7.130
tcpdump: listening on xl0
14:16:14.567917 sloan.lander.edu &gt; cio-sys.cisco.com: icmp: echo request
bsd1# tcpdump -c1 -n host 192.31.7.130
tcpdump: listening on xl0
14:17:09.737597 205.153.63.30 &gt; 192.31.7.130: icmp: echo request
bsd1# tcpdump -c1 -N host 192.31.7.130
tcpdump: listening on xl0
14:17:28.891045 sloan &gt; cio-sys: icmp: echo request
bsd1# tcpdump -c1 -f host 192.31.7.130
tcpdump: listening on xl0
14:17:49.274907 sloan.lander.edu &gt; 192.31.7.130: icmp: echo request</pre></blockquote>

Clearly, the <em class="filename">-a</em> option is the default.</p>

Not using name resolution can eliminate the overhead and produce
terser output. If the network is broken, you may not be able to reach
your name server and will find yourself with long delays, while name
resolution times out. Finally, if you are running
<em class="filename">tcpdump</em> interactively, name resolution will
create more traffic that will have to be filtered out.
</p>

<a name="INDEX-1010" /><a name="INDEX-1011" />The <em class="filename">-t</em> and
<em class="filename">-tt </em>options control the printing of timestamps.
The <em class="filename">-t</em> option suppresses the display of the
timestamp while <em class="filename">-tt</em> produces unformatted
timestamps. The following shows the output for the same packet using
<em class="filename">tcpdump</em> without an option, with the
<em class="filename">-t</em> option, and with the <em class="filename">-tt</em>
option, respectively:
</p>

<blockquote><pre class="code">12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 
win 8647 (DF)

sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 (DF)

934303014.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 
win 8647 (DF)</pre></blockquote>

The <em class="filename">-t</em> option produces a more terse output while
the <em class="filename">-tt</em> output can simplify subsequent
processing, particularly if you are writing scripts to process the
data.
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.3" /><div class="sect3">
<h3 class="sect3">5.4.2.3. Controlling what's displayed</h3>

<a name="INDEX-1012" /><a name="INDEX-1013" /><a name="INDEX-1014" />The
verbose modes provided by <em class="filename">-v</em> and
<em class="filename">-vv</em> options can be used to print some additional
information. For example, the <em class="filename">-v</em> option will
print TTL fields. For less information, use the
<em class="filename">-q,</em> or quiet, option. Here is the output for the
same packet presented with the <em class="filename">-q</em> option,
without options, with the <em class="filename">-v</em> option, and with
the <em class="filename">-vv</em> option, respectively:
</p>

<blockquote><pre class="code">12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: tcp 0 (DF)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 
win 8647 (DF)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 
win 8647 (DF) (ttl 128, id 45836)

12:36:54.772066 sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 
win 8647 (DF) (ttl 128, id 45836)</pre></blockquote>

This additional information might be useful in a few limited
contexts, while the quiet mode provides shorter output lines. In this
instance, there was no difference between the results with
<em class="filename">-v</em> and <em class="filename">-vv</em>, but this
isn't always the case.
</p>

<a name="INDEX-1015" />The <em class="filename">-e</em> option
is used to display link-level header information. For the packet from
the previous example, with the <em class="filename">-e </em>option, the
output is:
</p>

<blockquote><pre class="code">12:36:54.772066 0:10:5a:a1:e9:8 0:10:5a:e3:37:c ip 60: 
sloan.lander.edu.1174 &gt; 205.153.63.238.telnet: . ack 3259091394 win 8647 (DF)</pre></blockquote>

<em class="filename">0:10:5a:a1:e9:8</em> is the Ethernet address of the
3Com card in <em class="filename">sloan.lander.edu, </em>while
<em class="filename">0:10:5a:e3:37:c</em> is the Ethernet address of the
3Com card in <em class="filename">205.153.63.238</em>. (We can discover
the types of adapters used by looking up the OUI portion of these
addresses, as described in <a href="ch02_01.html">Chapter 2, "Host Configurations"</a>.)
</p>

<a name="INDEX-1016" /><a name="INDEX-1017" /><a name="INDEX-1018" />For
the masochist who wants to decode packets manually, the
<em class="filename">-x</em> option provides a hexadecimal dump of
packets, excluding link-level headers. A packet displayed with the
<em class="filename">-x</em> and <em class="filename">-vv</em> options looks
like this:
</p>

<blockquote><pre class="code">13:57:12.719718 bsd1.lander.edu.1657 &gt; 205.153.60.5.domain: 11587+ A? www.
microsoft.com. (35) (ttl 64, id 41353)
                         4500 003f a189 0000 4011 c43a cd99 3db2
                         cd99 3c05 0679 0035 002b 06d9 2d43 0100
                         0001 0000 0000 0000 0377 7777 096d 6963
                         726f 736f 6674 0363 6f6d 0000 0100 01</pre></blockquote>

Please note that the amount of information displayed will depend on
how many bytes are collected, as determined by the
<em class="filename">-s</em> option. Such hex listings are typical of what
might be seen with many capture programs.
</p>

Describing how to do such an analysis in detail is beyond the scope
of this book, as it requires a detailed understanding of the
structure of packets for a variety of protocols. Interpreting this
data is a matter of taking packets apart byte by byte or even bit by
bit, realizing that the interpretation of the results at one step may
determine how the next steps will be done. For header formats, you
can look to the appropriate RFC or in any number of books. <a href="ch05_04.html#nettroubletools-CHP-5-TABLE-1">Table 5-1</a> summarizes the analysis for this particular
packet, but every packet is different. This particular packet was a
DNS lookup for <em class="filename">www.microsoft.com</em>. (For more
information on decoding packets, see Eric A. Hall's
<em class="emphasis">Internet Core Protocols: The Definitive Guide</em>.)
</p>

<a name="nettroubletools-CHP-5-TABLE-1" /><h4 class="objtitle">Table 5-1. Packet analysis summary </h4><table border="1">



<tr>
<th>
Raw data in hex</p>
</th>
<th>
Interpretation</p>
</th>
</tr>


<tr>
<td>
<b class="emphasis-bold">IP header</b></p>
</td>
<td>

</td>
</tr>
<tr>
<td>
First 4 bits of 45</p>
</td>
<td>
IP version -- 4</p>
</td>
</tr>
<tr>
<td>
Last 4 bits of 45</p>
</td>
<td>
Length of header multiplier -- 5 (times 4 or 20 bytes)</p>
</td>
</tr>
<tr>
<td>
00</p>
</td>
<td>
Type of service</p>
</td>
</tr>
<tr>
<td>
00 3f</p>
</td>
<td>
Packet length in hex -- 63 bytes</p>
</td>
</tr>
<tr>
<td>
a1 89</p>
</td>
<td>
ID</p>
</td>
</tr>
<tr>
<td>
First 3 bits of 00</p>
</td>
<td>
000 -- flags, none set</p>
</td>
</tr>
<tr>
<td>
Last 13 bits of 00 00</p>
</td>
<td>
Fragmentation offset</p>
</td>
</tr>
<tr>
<td>
40</p>
</td>
<td>
TTL -- 64 hops</p>
</td>
</tr>
<tr>
<td>
11</p>
</td>
<td>
Protocol number in hex -- UDP</p>
</td>
</tr>
<tr>
<td>
c4 3a</p>
</td>
<td>
Header checksum</p>
</td>
</tr>
<tr>
<td>
cd 99 3d b2</p>
</td>
<td>
Source IP -- 205.153.61.178</p>
</td>
</tr>
<tr>
<td>
cd 99 3c 05</p>
</td>
<td>
Destination IP -- 205.153.60.5</p>
</td>
</tr>
<tr>
<td>
<b class="emphasis-bold">UDP header</b></p>
</td>
<td>

</td>
</tr>
<tr>
<td>
06 79</p>
</td>
<td>
Source port</p>
</td>
</tr>
<tr>
<td>
00 35</p>
</td>
<td>
Destination port -- DNS </p>
</td>
</tr>
<tr>
<td>
00 2b</p>
</td>
<td>
UDP packet length -- 43 bytes </p>
</td>
</tr>
<tr>
<td>
06 d9</p>
</td>
<td>
Header checksum</p>
</td>
</tr>
<tr>
<td>
<b class="emphasis-bold">DNS message</b></p>
</td>
<td>

</td>
</tr>
<tr>
<td>
2d 43</p>
</td>
<td>
ID</p>
</td>
</tr>
<tr>
<td>
01 00</p>
</td>
<td>
Flags -- query with recursion desired</p>
</td>
</tr>
<tr>
<td>
00 01</p>
</td>
<td>
Number of queries</p>
</td>
</tr>
<tr>
<td>
00 00</p>
</td>
<td>
Number of answers</p>
</td>
</tr>
<tr>
<td>
00 00</p>
</td>
<td>
Number of authority RRs</p>
</td>
</tr>
<tr>
<td>
00 00</p>
</td>
<td>
Number of additional RRs</p>
</td>
</tr>
<tr>
<td>
<b class="emphasis-bold">Query</b></p>
</td>
<td>

</td>
</tr>
<tr>
<td>
03 </p>
</td>
<td>
Length -- 3</p>
</td>
</tr>
<tr>
<td>
77 77 77</p>
</td>
<td>
String -- "www"</p>
</td>
</tr>
<tr>
<td>
09</p>
</td>
<td>
Length -- 9</p>
</td>
</tr>
<tr>
<td>
6d 69 63 72 6f 73 6f 66 74</p>
</td>
<td>
String -- "microsoft"</p>
</td>
</tr>
<tr>
<td>
03</p>
</td>
<td>
Length -- 3</p>
</td>
</tr>
<tr>
<td>
63 6f 6d</p>
</td>
<td>
String -- "com"</p>
</td>
</tr>
<tr>
<td>
00</p>
</td>
<td>
Length -- 0</p>
</td>
</tr>
<tr>
<td>
00 01 </p>
</td>
<td>
Query type -- IP address</p>
</td>
</tr>
<tr>
<td>
00 01</p>
</td>
<td>
Query class -- Internet</p>
</td>
</tr>

</table><p>

<a name="INDEX-1021" /><a name="INDEX-1022" /><a name="INDEX-1023" />This analysis was included here primarily
to give a better idea of how packet analysis works. Several programs
that analyze packet data from a <em class="filename">tcpdump</em> trace
file are described later in this chapter. Unix utilities like
<em class="filename">strings</em>, <em class="filename">od</em>, and
<em class="filename">hexdump</em> can also make the process easier. For
example, in the following example, this makes it easier to pick out
<em class="emphasis">www.microsoft.com</em> in the data:
</p>

<blockquote><pre class="code">bsd1# hexdump -C tracefile
00000000  d4 c3 b2 a1 02 00 04 00  00 00 00 00 00 00 00 00  |................|
00000010  c8 00 00 00 01 00 00 00  78 19 06 38 66 fb 0a 00  |........x..8f...|
00000020  4d 00 00 00 4d 00 00 00  00 00 a2 c6 0e 43 00 60  |M...M........C.`|
00000030  97 92 4a 7b 08 00 45 00  00 3f a1 89 00 00 40 11  |..J{..E..?....@.|
00000040  c4 3a cd 99 3d b2 cd 99  3c 05 06 79 00 35 00 2b  |.:..=...&lt;..y.5.+|
00000050  06 d9 2d 43 01 00 00 01  00 00 00 00 00 00 03 77  |..-C...........w|
00000060  77 77 09 6d 69 63 72 6f  73 6f 66 74 03 63 6f 6d  |ww.microsoft.com|
00000070  00 00 01 00 01                                    |.....|
00000075</pre></blockquote>

The <em class="filename">-vv</em> option could also be used to get as much
information as possible.
</p>

<a name="INDEX-1024" /><a name="INDEX-1025" /><a name="INDEX-1026" />Hopefully, you will have little need for
the <em class="filename">-x</em> option. But occasionally you may
encounter a packet that is unknown to <em class="filename">tcpdump,</em>
and you have no choice. For example, some of the switches on my local
network use a proprietary implementation of a spanning tree protocol
to implement virtual local area networks (VLANs). Most packet
analyzers, including <em class="filename">tcpdump</em>, won't
recognize these. Fortunately, once you have decoded one unusual
packet, you can usually easily identify similar packets.
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.4" /><div class="sect3">
<h3 class="sect3">5.4.2.4. Filtering</h3>

<a name="INDEX-1027" /><a name="INDEX-1028" />To
effectively use <em class="filename">tcpdump</em>, it is necessary to
master the use of filters. Filters permit you to specify what traffic
you want to capture, allowing you to focus on just what is of
interest. This can be absolutely essential if you need to extract a
small amount of traffic from a massive trace file. Moreover, tools
like <em class="filename">ethereal</em> use the
<em class="filename">tcpdump</em> filter syntax for capturing traffic, so
you'll want to learn the syntax if you plan to use these tools.
</p>

<a name="INDEX-1029" /><a name="INDEX-1030" />If
you are absolutely certain that you are not interested in some kinds
of traffic, you can exclude traffic as you capture. If you are
unclear of what traffic you want, you can collect the raw data to a
file and apply the filters as you read back the file. In practice,
you will often alternate between these two approaches.
</p>

<a name="INDEX-1031" /><a name="INDEX-1032" /><a name="INDEX-1033" /><a name="INDEX-1034" />Filters at their simplest are keywords
added to the end of the command line. However, extremely complex
commands can be constructed using logical and relational operators.
In the latter case, it is usually better to save the filter to a file
and use the <em class="filename">-F</em> option. For example, if
<em class="filename">testfilter</em> is a text file containing the filter
<tt class="literal">host 205.153.63.30</tt>, then typing <tt class="literal">tcpdump
-Ftestfilter</tt> is equivalent to typing the command
<em class="emphasis">tcpdump host 205.153.63.30.</em> Generally, you will
want to use this feature with complex filters only. However, you
can't combine filters on the command line with a filters file
in the same command.
</p>

<a name="nettroubletools-CHP-5-SECT-4.2.4.1" /><div class="sect4">
<h4 class="sect4">5.4.2.4.1. Address filtering.</h4><a name="INDEX-1035" /><a name="INDEX-1036" /><a name="INDEX-1037" />

It should come as no surprise that filters can select traffic based
on addresses. For example, consider the command:
</p>

<blockquote><pre class="code">bsd1# tcpdump host 205.153.63.30</pre></blockquote>

<a name="INDEX-1038" />This
command captures all traffic to and from the host with the IP address
205.153.63.30. The host may be specified by IP number or name. Since
an IP address has been specified, you might incorrectly guess that
the captured traffic will be limited to IP traffic. In fact, other
traffic, such as ARP traffic, will also be collected by this filter.
Restricting capture to a particular protocol requires a more complex
filter. Nonintuitive behavior like this necessitates a thorough
testing of all filters.
</p>

Addresses can be specified and restricted in several ways. Here is an
example that uses the Ethernet address of a computer to select
traffic:
</p>

<blockquote><pre class="code">bsd1# tcpdump ether host 0:10:5a:e3:37:c</pre></blockquote>

<a name="INDEX-1039" /><a name="INDEX-1040" />Capture
can be further restricted to traffic flows for a single direction,
either to a host or from a host, using <em class="filename">src</em> to
specify the source of the traffic or <em class="filename">dst</em> to
specify the destination. The next example shows a filter that
collects traffic sent to the host at
<em class="filename">205.153.63.30</em> but not from it:
</p>

<blockquote><pre class="code">bsd1# tcpdump dst 205.153.63.30 </pre></blockquote>

Note that the keyword <em class="filename">host</em> was omitted in this
example. Such omissions are OK in several instances, but it is always
safer to include these keywords.
</p>

<a name="INDEX-1041" /><a name="INDEX-1042" /><a name="INDEX-1043" />Multicast
or broadcast traffic can be selected by using the keyword
<em class="filename">multicast</em> or <em class="filename">broadcast,</em>
respectively. Since multicast and broadcast traffic are specified
differently at the link level and the network level, there are two
forms for each of these filters. The filter <em class="filename">ether
multicast</em> captures traffic with an Ethernet multicast
address, while <em class="filename">ip multicast</em> captures traffic
with an IP multicast address. Similar qualifiers are used with
broadcast traffic. Be aware that multicast filters may capture
broadcast traffic. As always, test your filters.
</p>

Traffic capture can be restricted to networks as well as hosts. For
example, the following command restricts capture to packets coming
from or going to the 205.153.60.0 network:
</p>

<blockquote><pre class="code">bsd1# tcpdump net 205.153.60</pre></blockquote>

The following command does the same thing:</p>

<blockquote><pre class="code">bsd1# tcpdump net 205.153.60.0 mask 255.255.255.0</pre></blockquote>

Although you might guess otherwise, the following command does not
work properly due to the final <tt class="literal">.0</tt>:
</p>

<blockquote><pre class="code">bsd1# tcpdump net 205.153.60.0</pre></blockquote>

<a name="INDEX-1044" /><a name="INDEX-1045" />Be
sure to test your filters!
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.4.2" /><div class="sect4">
<h4 class="sect4">5.4.2.4.2. Protocol and port filtering.</h4><a name="INDEX-1046" /><a name="INDEX-1047" /><a name="INDEX-1048" /><a name="INDEX-1049" /><a name="INDEX-1050" /><a name="INDEX-1051" />

It is possible to restrict capture to specific protocols such as IP,
Appletalk, or TCP. You can also restrict capture to services built on
top of these protocols, such as DNS or RIP. This type of capture can
be done in three ways -- by using a few specific keywords known by
<em class="filename">tcpdump</em>, by protocol using the
<em class="filename">proto</em> keyword, or by service using the
<em class="filename">port</em> keyword.
</p>

Several of these protocol names are recognized by <em class="filename">tcpdump
</em>and can be identified by keyword<em class="emphasis">.</em> The
following command restricts the traffic captured to IP traffic:
</p>

<blockquote><pre class="code">bsd1# tcpdump ip</pre></blockquote>

<a name="INDEX-1052" /><a name="INDEX-1053" />Of
course, IP traffic will include TCP traffic, UDP traffic, and so on.
</p>

To capture just TCP traffic, you would use:</p>

<blockquote><pre class="code">bsd1# tcpdump tcp</pre></blockquote>

<a name="INDEX-1054" /><a name="INDEX-1055" />Recognized keywords include
<em class="filename">ip</em>, <em class="filename">igmp</em>,
<em class="filename">tcp</em>, <em class="emphasis">udp</em>, and
<em class="filename">icmp</em>.
</p>

<a name="INDEX-1056" /><a name="INDEX-1057" /><a name="INDEX-1058" />There are many transport-level services
that do not have recognized keywords. In this case, you can use the
keywords <em class="filename">proto</em> or <em class="filename">ip proto</em>
followed by either the name of the protocol found in the
<em class="filename">/etc/protocols</em> file or the corresponding
protocol number. For example, either of the following will look for
OSPF packets:
</p>

<blockquote><pre class="code">bsd1# tcpdump ip proto ospf
bsd1# tcpdump ip proto 89</pre></blockquote>

Of course, the first works only if there is an entry in
<em class="filename">/etc/protocols</em> for OSPF.
</p>

Built-in keywords may cause problems. In these examples, the keyword
<em class="filename">tcp</em> must either be escaped or the number must be
used. For example, the following is fine:
</p>

<blockquote><pre class="code">bsd#1 tcpdump ip proto 6 </pre></blockquote>

On the other hand, you can't use <em class="filename">tcp</em> with
<em class="filename">proto</em>.
</p>

<blockquote><pre class="code">bsd#1 tcpdump ip proto tcp </pre></blockquote>

will generate an error.</p>

<a name="INDEX-1059" />For higher-level services, services
built on top of the underlying protocols, you must use the keyword
<em class="filename">port</em>. Either of the following will collect DNS
traffic:
</p>

<blockquote><pre class="code">bsd#1 tcpdump port domain 
bds#1 tcpdump port 53</pre></blockquote>

In the former case, the keyword <em class="filename">domain</em> is
resolved by looking in <em class="filename">/etc/services</em>. When there
may be ambiguity between transport-layer protocols, you may further
restrict ports to a particular protocol. Consider the command:
</p>

<blockquote><pre class="code">bsd#1 tcpdump udp port domain</pre></blockquote>

This will capture DNS name lookups using UDP but not DNS zone
transfers using TCP. The two previous commands would capture both.
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.4.3" /><div class="sect4">
<h4 class="sect4">5.4.2.4.3. Packet characteristics.</h4><a name="INDEX-1060" /><a name="INDEX-1061" /><a name="INDEX-1062" /><a name="INDEX-1063" /><a name="INDEX-1064" /><a name="INDEX-1065" /><a name="INDEX-1066" />

Filters can also be designed based on packet characteristics such as
packet length or the contents of a particular field. These filters
must include a relational operator. To use length, the keyword
<em class="filename">less</em> or <em class="filename">greater</em> is used.
Here is an example:
</p>

<blockquote><pre class="code">bsd1# tcpdump greater 200</pre></blockquote>

This command collects packets longer than 200 bytes.</p>

<a name="INDEX-1067" /><a name="INDEX-1068" />Looking inside packets is a little more
complicated in that you must understand the structure of the
packet's header. But despite the complexity, or perhaps because
of it, this technique gives you the greatest control over what is
captured. (If you are charged with creating a firewall using a
product that requires specifying offsets into headers, practicing
with <em class="filename">tcpdump</em> could prove invaluable.)
</p>

<a name="INDEX-1069" /><a name="INDEX-1070" /><a name="INDEX-1071" />The general syntax is
<em class="replaceable">proto [ expr : size ]</em>. The field
<em class="filename">proto</em> indicates which header to look
into -- <em class="filename">ip</em> for the IP header,
<em class="filename">tcp</em> for the TCP header, and so forth. The
<em class="filename">expr</em> field gives an offset into the header
indexed from 0. That is, the first byte in a header is number 0, the
second byte is number 1, and so forth. Alternately, you can think of
<em class="filename">expr</em> as the number of bytes in the header to
skip over. The <em class="filename">size</em> field is optional. It
specifies the number of bytes to use and can be 1, 2, or 4.
</p>

<blockquote><pre class="code">bsd1# tcpdump "ip[9] = 6" </pre></blockquote>

looks into the IP header at the tenth byte, the protocol field, for a
value of 6. Notice that this must be quoted. Either an apostrophe or
double quotes should work, but a backquote will not work.
</p>

<blockquote><pre class="code">bsd1# tcpdump tcp</pre></blockquote>

is an equivalent command since 6 is the protocol number for TCP.</p>

<a name="INDEX-1072" /><a name="INDEX-1073" /><a name="INDEX-1074" />This
technique is frequently used with a mask to select specific bits.
Values should be in hex. Comparisons are specified using the syntax
<em class="filename">&amp; </em>followed by a bit mask. The next example
extracts the first byte from the Ethernet header (i.e., the first
byte of the destination address), extracts the low-order bit, and
makes sure the bit is not 0:<a href="#FOOTNOTE-25">[25]</a>
</p><blockquote class="footnote"> <a name="FOOTNOTE-25" />[25]The astute reader will
notice that this test could be more concisely written as
<em class="filename">=1</em> rather than <em class="filename">!=0</em>. While
it doesn't matter for this example, using the second form
simplifies testing in some cases and is a common idiom. In the next
command, the syntax is simpler since you are testing to see if
multiple bits are set.</p> </blockquote>

<blockquote><pre class="code">bsd1# tcpdump 'ether[0] &amp; 1 != 0' </pre></blockquote>

<a name="INDEX-1075" /><a name="INDEX-1076" />This
will match multicast and broadcast packets.
</p>

With both of these examples, there are better ways of matching the
packets. For a more realistic example, consider the command:
</p>

<blockquote><pre class="code">bsd1# tcpdump "tcp[13] &amp; 0x03 != 0"</pre></blockquote>

<a name="INDEX-1077" /><a name="INDEX-1078" /><a name="INDEX-1079" />This filter skips the first 13 bytes in
the TCP header, extracting the flag byte. The mask
<em class="filename">0x03</em> selects the first and second bits, which
are the FIN and SYN bits. A packet is captured if either bit is set.
This will capture setup or teardown packets for a TCP connection.
</p>

<a name="INDEX-1080" /><a name="INDEX-1081" /><a name="INDEX-1082" /><a name="INDEX-1083" />It is tempting to try to mix in
relational operators with these logical operators. Unfortunately,
expressions like <em class="filename">tcp src port &gt; 23</em>
don't work. The best way of thinking about it is that the
expression <em class="filename">tcp src port</em> returns a value of true
or false, not a numerical value, so it can't be compared to a
number. If you want to look for all TCP traffic with a source port
with a value greater than 23, you must extract the port field from
the header using syntax such as <em class="filename">"tcp[0:2] &amp;
0xffff &gt; 0x0017"</em>.
</p>

</div>

<a name="nettroubletools-CHP-5-SECT-4.2.4.4" /><div class="sect4">
<h4 class="sect4">5.4.2.4.4. Compound filters.</h4><a name="INDEX-1084" /><a name="INDEX-1085" /><a name="INDEX-1086" /><a name="INDEX-1087" /><a name="INDEX-1088" /><a name="INDEX-1089" /><a name="INDEX-1090" /><a name="INDEX-1091" /><a name="INDEX-1092" />

All the examples thus far have consisted of simple commands with a
single test. Compound filters can be constructed in
<em class="filename">tcpdump</em> using logical operator
<tt class="literal">and</tt>, <tt class="literal">or</tt>, and
<tt class="literal">not</tt>. These are often abbreviated
<tt class="literal">&amp;&amp;</tt>, <tt class="literal">||</tt>, and
<tt class="literal">!</tt> respectively. Negation has the highest
precedence. Precedence is left to right in the absence of
parentheses. While parentheses can be used to change precedence,
remember that they must be escaped or
quoted.<a name="INDEX-1093" />
</p>

Earlier it was noted that the following will not limit capture to
just IP traffic:
</p>

<blockquote><pre class="code">bsd1# tcpdump host 205.153.63.30 </pre></blockquote>

If you really only want IP traffic in this case, use the command:</p>

<blockquote><pre class="code">bsd1# tcpdump host 205.153.63.30 and ip</pre></blockquote>

On the other hand, if you want all traffic to the host except IP
traffic, you could use:
</p>

<blockquote><pre class="code">bsd1# tcpdump host 205.153.63.30 and not ip </pre></blockquote>

If you need to capture all traffic to and from the host and all
non-IP traffic, replace the <tt class="literal">and</tt> with an
<tt class="literal">or</tt>.
</p>

With complex expressions, you have to be careful of the precedence.
Consider the two commands:
</p>

<blockquote><pre class="code">bsd1# tcpdump host lnx1 and udp or arp
bsd1# tcpdump "host lnx1 and (udp or arp)" </pre></blockquote>

The first will capture all UDP traffic to or from
<em class="filename">lnx1</em> and all ARP traffic. What you probably want
is the second, which captures all UDP or ARP traffic to or from
<em class="filename">lxn1</em>. But beware, this will also capture ARP
broadcast traffic. To beat a dead horse, be sure to test your
filters.
</p>

<a name="INDEX-1094" /><a name="INDEX-1095" /><a name="INDEX-1096" />I mentioned earlier that running
<em class="filename">tcpdump</em> on a remote station using
<em class="filename">telnet</em> was one way to collect data across your
network, except that the Telnet traffic itself would be captured. It
should be clear now that the appropriate filter can be used to avoid
this problem. To eliminate a specific TCP connection, you need four
pieces of information -- the source and destination IP addresses
and the source and destination port numbers. In practice, the two IP
addresses and the well-known port number is often enough.
</p>

For example, suppose you are interested in capturing traffic on the
host <em class="filename">lnx1</em>, you are logged onto the host
<em class="filename">bsd1</em>, and you are using
<em class="filename">telnet</em> to connect from <em class="filename">bsd1</em>
to <em class="filename">lnx1</em>. To capture all the traffic at
<em class="filename">lnx1</em>, excluding the Telnet traffic between
<em class="filename">bsd1</em> and <em class="filename">lnx1</em>, the
following command will probably work adequately in most cases:
</p>

<blockquote><pre class="code">lnx1# tcpdump -n "not (tcp port telnet and host lnx1 and host bsd1)"</pre></blockquote>

We can't just exclude Telnet traffic since that would exclude
all Telnet traffic between <em class="filename">lnx1</em> and any host. We
can't just exclude traffic to or from one of the hosts because
that would exclude non-Telnet traffic as well. What we want to
exclude is just traffic that is Telnet traffic, has
<em class="filename">lnx1</em> as a host, and has
<em class="filename">bsd1</em> as a host. So we take the negation of these
three requirements to get everything else.
</p>

<a name="INDEX-1097" /><a name="INDEX-1098" />While this filter is usually adequate,
this filter excludes all Telnet sessions between the two hosts, not
just yours. If you really want to capture other Telnet traffic
between <em class="filename">lnx1</em> and <em class="filename">bsd1</em>, you
would need to include a fourth term in the negation giving the
ephemeral port assigned by <em class="filename">telnet</em>. You'll
need to run <em class="filename">tcpdump</em> twice, first to discover the
ephemeral port number for your current session since it will be
different with every session, and then again with the full filter to
capture the traffic you are interested in.
</p>

<a name="INDEX-1099" />One other observation -- while we are
not reporting the traffic, the traffic is still there. If you are
investigating a bandwidth problem, you have just added to the
traffic. You can, however, minimize this traffic during the capture
if you write out your trace to a file on <em class="filename">lnx1</em>
using the <em class="filename">-w</em> option. This is true, however, only
if you are using a local filesystem. Finally, note the use of the
<em class="filename">-n</em> option. This is required to prevent name
resolution. Otherwise, <em class="filename">tcpdump</em> would be creating
additional network traffic in trying to resolve IP numbers into names
as noted earlier.
</p>

Once you have mastered the basic syntax of
<em class="filename">tcpdump</em>, you should run
<em class="filename">tcpdump</em> on your own system without any filters.
It is worthwhile to do this occasionally just to see what sorts of
traffic you have on your network. There are likely to be a number of
surprises. In particular, there may be router protocols, switch
topology information exchange, or traffic from numerous PC-based
protocols that you aren't expecting. It is very helpful to know
that this is normal traffic so when you have problems you won't
blame the problems on this strange traffic.
</p>

This has not been an exhaustive treatment of
<em class="filename">tcpdump,</em> but I hope that it adequately covers
the basics. The manpage for <em class="filename">tcpdump</em> contains a
wealth of additional information, including several detailed examples
with explanations. One issue I have avoided has been how to interpret
<em class="filename">tcpdump</em> data. Unfortunately, this depends upon
the protocol and is really beyond the scope of a book such as this.
Ultimately, you must learn the details of the protocols. For TCP/IP,
Richard W. Stevens' <em class="filename">TCP/IP Illustrated,
</em>vol. 1<em class="filename">, The Protocols</em> has extensive
examples using <em class="filename">tcpdump</em>. But the best way to
learn is to use <em class="filename">tcpdump</em> to examine the behavior
of working systems.<a name="INDEX-1100" /><a name="INDEX-1101" /><a name="INDEX-1102" /><a name="INDEX-1103" /><a name="INDEX-1104" /><a name="INDEX-1105" /> 
</p>

</div>
</div>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch05_03.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch05_05.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">5.3. Capturing Data</td><td align="center" valign="top" width="228"><a href="index/index.html"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">5.5. Analysis Tools</td></tr></table><div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.html">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,84,90" href="../index.html" /><area shape="rect" coords="86,-7,176,90" href="../ssh/index.html" /><area shape="rect" coords="178,0,265,101" href="../tcp/index.html" /><area shape="rect" coords="266,0,333,90" href="../nfs/index.html" /><area shape="rect" coords="334,-1,429,93" href="../snmp/index.html" /><area shape="rect" coords="431,0,529,116" href="index.html" /><area shape="rect" coords="534,0,594,104" href="../dns/index.html" /><area shape="rect" coords="595,1,704,108" href="../fire/index-2.html" /></map>

</body>
<!-- Mirrored from nnc3.com/mags/Networking2/tshoot/ch05_04.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:57:04 GMT -->
</html>