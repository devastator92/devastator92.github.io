<html>
<!-- Mirrored from nnc3.com/mags/Networking2/ssh/ch07_04.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:10 GMT -->
<head><title>Client Configuration in Depth (SSH, The Secure Shell: The Definitive Guide)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Daniel J. Barrett and Richard E. Silverman" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0596000111L" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="SSH, The Secure Shell: The Definitive Guide" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img alt="Book Home" border="0" src="gifs/smbanner.gif" usemap="#banner-map" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.html" alt="SSH, The Secure Shell" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.html" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_03.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"></a></td><td align="right" valign="top" width="228"><a href="ch07_05.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr></table><div>



<h2 class="sect1">7.4. Client Configuration in Depth</h2>



<tt class="command">ssh</tt> and <tt class="command">scp</tt> take their cues
from command-line options, configuration-file keywords, and
environment variables. SSH1, SSH2, and OpenSSH clients behave
differently and obey different settings, but as usual, we cover them
simultaneously. When a setting is supported by only some of these
products, we'll say so.</p>



<a name="ch07-8-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.1. Remote Account Name</h3>



<tt class="command">ssh</tt> and <tt class="command">scp</tt> assume that your
local and remote usernames are the same. If your local username is
henry and you run:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh server.example.com</pre></blockquote>



<tt class="command">ssh</tt> will assume your remote username is also henry
and requests a connection to that account on <em class="emphasis">server.example.com</em>. If your remote
account name differs from the local one, you must tell the SSH client
your remote account name. For henry to connect to a remote account
called sally, he can use the <span class="option">-l</span> command-line option:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -l sally server.example.com</pre></blockquote>



If copying files with <tt class="command">scp</tt>, the syntax is different
for specifying the remote account name, looking more like an email
address. [<a href="ch07_05.html#ch07-43251">Section 7.5.1, "Full Syntax"</a>] To copy the file
<em class="filename">myfile</em> to the remote account sally on
<em class="emphasis">server.example.com</em>:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ scp myfile sally@server.example.com:</pre></blockquote>



If you frequently connect to a remote machine using a different
username, instead of monkeying with command-line options, specify the
remote username in your client configuration file. The
<tt class="literal">User</tt><a name="INDEX-1150" />
keyword serves this purpose, and both <tt class="command">ssh</tt> and
<tt class="command">scp</tt> pay attention to it. The following table shows
how to declare that your remote username is sally on a given remote
host:</p>



<a name="ch07-9-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code">Host server.example.com
 User sally</pre></blockquote></td>
<td>
<blockquote><pre class="code">server.example.com:
 User sally</pre></blockquote></td>
</tr>



</table><p>

Now, when connecting to <em class="emphasis">server.example.com</em>, you don't have
to specify that your remote username is sally:</p>



<blockquote><pre class="code"># The remote username sally will be used automatically
$ ssh server.example.com</pre></blockquote>



<a name="ch07-10-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.1.1. Tricks with remote account names</h3>



With <tt class="literal">User</tt> and nicknames, you can significantly
shorten the command lines you type for <tt class="command">ssh</tt> and
<tt class="command">scp</tt>. Continuing the preceding example with
"sally", if you have the configuration shown in this
table:</p>



<a name="ch07-11-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code">Host simple
 HostName server.example.com
 User sally</pre></blockquote></td>
<td>
<blockquote><pre class="code">simple:
 Host server.example.com
 User sally</pre></blockquote></td>
</tr>



</table><p>

then these long commands:</p>



<blockquote><pre class="code">$ ssh server.example.com -l sally
$ scp myfile sally@server.example.com:</pre></blockquote>



may be reduced to:</p>



<blockquote><pre class="code">$ ssh simple
$ scp myfile simple:</pre></blockquote>



This table shows how you can specify separately several different
accounts names on different hosts, each in its own section of the
configuration file:</p>



<a name="ch07-12-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code">Host server.example.com
 User sally
 ...
Host another.example.com
 User sharon
 ...</pre></blockquote></td>
<td>
<blockquote><pre class="code">server.example.com:
 User sally
 ...
another.example.com:
 User sharon
 ...</pre></blockquote></td>
</tr>



</table><p>

This technique is convenient if you have only one account on each
remote machine. But suppose you have two accounts on <em class="emphasis">server.example.com</em>, called sally and
sally2. Is there some way to specify both in the configuration file?
The following attempt doesn't work (we show SSH1 syntax only):</p>



<blockquote><pre class="code"># THIS WILL NOT WORK PROPERLY
Host server.example.com
 User sally
 User sally2
 Compression yes</pre></blockquote>



because only the first value (sally) prevails. To get around this
limitation, you can use nicknames to create two sections for the same
machine in your configuration file, each with a different
<tt class="literal">User</tt>:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
# Section 1: Convenient access to the sally account
Host sally-account
 HostName server.example.com
 User sally
 Compression yes

# Section 2: Convenient access to the sally2 account
Host sally2-account
 HostName server.example.com
 User sally2
 Compression yes</pre></blockquote>



Now you can access the two accounts easily by nickname:</p>



<blockquote><pre class="code">$ ssh sally-account
$ ssh sally2-account</pre></blockquote>



This works, but it isn't ideal. You've duplicated your
settings (<tt class="literal">HostName</tt> and
<tt class="literal">Compression</tt>) in each section. Duplication makes a
configuration file harder to maintain, since any future changes needs
to be applied twice. (In general, duplication isn't good
software engineering.) Are you doomed to duplicate? No, there's
a better solution. Immediately after the two sections, create a third
section with a <tt class="literal">Host</tt> wildcard that matches both
sally-account and sally2-account. Suppose you use sally*-account and
move all duplicated settings into this new section:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
Host sally*-account
 HostName server.example.com
 Compression yes</pre></blockquote>



The end result is shown in this table:</p>



<a name="ch07-13-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code">Host sally-account
 User sally
Host sally2-account
 User sally2
Host sally*-account
 HostName server.example.com
 Compression yes</pre></blockquote></td>
<td>
<blockquote><pre class="code">sally-account:
 User sally
sally2-account:
 User sally2
sally*-account:
 Host server.example.com
 Compression yes</pre></blockquote></td>
</tr>



</table><p>

Since sally*-account matches both previous sections, its full name
and compression settings apply to both sally-account and
sally2-account. Any settings that differ between sally-account and
sally2-account (in this case, <tt class="literal">User</tt>) are kept in
their respective sections. You've now achieved the same effect
as in the previous example -- two accounts with different settings
on the same remote machine -- but with no duplication of settings.</p>
</div>
</div>








<a name="ch07-80828" /><div class="sect2">
<h3 class="sect2">7.4.2. User Identity</h3>



SSH identifies you by an
<tt class="command">identity</tt><a name="INDEX-1151" /><a name="INDEX-1152" />
represented by a key pair (SSH-1) or a collection of key pairs
(SSH-2). [<a href="ch06_01.html#ch06-60666">Section 6.1, "What Is an Identity?"</a>] Normally, SSH clients use your
default key file (SSH1, OpenSSH) or default identification file
(SSH2) to establish an authenticated connection. However, if
you've created other keys, you may instruct SSH clients to use
them to establish your identity. A command-line option
(<span class="option">-i</span> ) and configuration keyword
(<a name="INDEX-1153" /><tt class="literal">IdentityFile</tt>)
are available for this purpose.</p>



In SSH1 and OpenSSH, for example, if you have a private key file
called <em class="filename">my-key</em>, you can make clients use it with
the commands:</p>



<blockquote><pre class="code">$ ssh1 -i my-key server.example.com
$ scp1 -i my-key myfile server.example.com:</pre></blockquote>



or with the configuration keyword:</p>



<blockquote><pre class="code">IdentityFile my-key</pre></blockquote>



The file location is assumed to be relative to the current directory,
i.e., in these cases the file is <em class="filename">./my-key</em>.</p>



SSH2 also has <span class="option">-i</span> and
<tt class="literal">IdentityFile</tt>, but their use is slightly different.
Instead of a key file, you supply the name of an identification
file:<a href="#FOOTNOTE-93">[93]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-93" />[93]In SSH2 2.0.13 and earlier, the <em class="filename">-i
</em>option and <tt class="literal">IdentityFile</tt> require the
identity file to be in your SSH2 directory,
<em class="filename">~/.ssh2</em>. SSH2 2.1.0 and later accept absolute
pathnames; any path that doesn't begin with a slash ( /) is
treated as relative to <em class="filename">~/.ssh2</em>.</p>


</blockquote>



<blockquote><pre class="code">$ ssh2 -i my-id-file server.example.com

IdentityFile my-id-file</pre></blockquote>



Take note of this difference between <tt class="command">ssh1</tt> and
<tt class="command">ssh2</tt>. If you mistakenly provide a key filename to
<tt class="command">ssh2</tt>, the client attempts to read the key file as
if it's an identification file, sending a random result to the
SSH2 server. Authentication mysteriously fails, possibly with the log
message "No further authentication methods available," or
you may be prompted for your login password rather than your public
key passphrase.</p>



Multiple <a name="INDEX-1154" />identities can be quite useful. [<a href="ch06_04.html#ch06-27873">Section 6.4, "Multiple Identities"</a>] For example, you can set up your remote
account to run specific programs when a second key is used. The
ordinary command:</p>



<blockquote><pre class="code">$ ssh server.example.com</pre></blockquote>



initiates a regular login session, but:</p>



<blockquote><pre class="code">$ ssh -i other_identity server.example.com</pre></blockquote>



can run a complex batch process on <em class="emphasis">server.example.com</em>. Using configuration
keywords, you can accomplish the same effect by specifying an
alternative identity as shown in this table:</p>



<a name="ch07-14-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code">Host SomeComplexAction
 HostName server.example.com
 IdentityFile other_identity
 ...</pre></blockquote></td>
<td>
<blockquote><pre class="code">SomeComplexAction:
 Host server.example.com
 IdentityFile other_identity
 ...</pre></blockquote></td>
</tr>



</table><p>

You can then invoke:</p>



<blockquote><pre class="code">$ ssh SomeComplexAction</pre></blockquote>



SSH1 and OpenSSH can specify multiple identities in a single
command:<a href="#FOOTNOTE-94">[94]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-94" />[94]SSH2 accomplishes the same thing with
identification files, which may contain multiple keys.</p>


</blockquote>



<blockquote><pre class="code"># SSH1, OpenSSH
$ ssh -i id1 -i id2 -i id3 server.example.com</pre></blockquote>



or:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
Host server.example.com
 IdentityFile id1
 IdentityFile id2
 IdentityFile id3</pre></blockquote>



Multiple identities are tried in order until one successfully
authenticates. However, SSH1 and OpenSSH limit you to 100 identities
per command.</p>



If you plan to use multiple identities frequently, remember that an
SSH agent can eliminate hassle. Simply load each identity's key
into the agent using <tt class="command">ssh-add</tt>, and you won't
have to remember multiple passphrases while you work.</p>
</div>








<a name="ch07-11389" /><div class="sect2">
<h3 class="sect2">7.4.3. Host Keys and Known-Hosts Databases</h3>



Every SSH server has a host key [<a href="ch03_03.html#ch03-59754">Section 3.3, "The Architecture of an SSH System"</a>] that
uniquely identifies the server to clients. This key helps prevent
spoofing attacks. When an SSH client requests a connection and
receives the server's host key, the client checks it against a
local database of known host keys. If the keys match, the connection
proceeds. If they don't, the client behaves according to
several options you can control.</p>



In SSH1 and OpenSSH, the host key database is maintained partly in a
serverwide location
(<em class="filename">/etc/ssh_known_hosts</em><a name="INDEX-1155" />) and partly in the user's SSH
directory
(<em class="filename">~/.ssh/known_hosts</em><a name="INDEX-1156" />).<a href="#FOOTNOTE-95">[95]</a> In SSH2,
there are two databases of host keys for authenticating server hosts
(the "hostkeys" map in
<em class="filename">/etc/ssh2/hostkeys</em><a name="INDEX-1157" />) and client hosts (the
"knownhosts" map); in this section we are concerned only
with the former. Similar to its SSH1 counterpart, the SSH2 hostkeys
map is maintained in a serverwide directory
(<em class="filename">/etc/ssh2/hostkeys/</em> ) and a per-account
directory (<em class="filename">~/.ssh2/hostkeys/ </em>). In this section,
we refer to the SSH1, SSH2, and OpenSSH map simply as the
<tt class="command">host key database</tt>.</p><blockquote class="footnote">


<a name="FOOTNOTE-95" />[95]OpenSSH additionally keeps SSH-2 known host keys in the file
<em class="filename">~/.ssh/known_hosts2</em>.</p>


</blockquote>



<a name="ch07-39605" /><div class="sect3">
<h3 class="sect3">7.4.3.1. Strict host key checking</h3>



Suppose you request an SSH connection with <em class="emphasis">server.example.com</em>, which sends its host
key in response. Your client looks up <em class="emphasis">server.example.com</em> in its host key
database. Ideally, a match is found and the connection proceeds. But
what if this doesn't happen? Two scenarios may arise:</p>



<dl>
<dt><i>SCENARIO 1</i></dt>
<dd>A host key is found for <em class="emphasis">server.example.com</em> in the database, but
it doesn't match the incoming key. This can indicate a security
hazard, or it can mean that <em class="emphasis">server.example.com</em> has changed its host
key, which can happen legitimately. [<a href="ch03_10.html#ch03-77405">Section 3.10.4, "Man-in-the-Middle Attacks"</a>]</p></dd>



<dt><i>SCENARIO 2</i></dt>
<dd>No host key for <em class="emphasis">server.example.com</em> exists in the
database. In this case, the SSH client is encountering <em class="emphasis">server.example.com</em> for the first time.</p></dd>

</dl>



In each scenario, should the client proceed or fail? Should it store
the new host key in the database, or not? These decisions are
controlled by the keyword
<tt class="literal">StrictHostKeyChecking</tt><a name="INDEX-1158" />,
which may have three values:</p>



<dl>
<dt><i><tt class="literal">yes</tt></i></dt>
<dd>Be strict. If a key is unknown or has changed, the connection fails.
This is the most secure value, but it can be inconvenient or annoying
if you connect to new hosts regularly, or if your remote host keys
change frequently.</p></dd>



<dt><i><tt class="literal">no</tt></i></dt>
<dd>Not strict. If a key is unknown, automatically add it to the
user's database and proceed. If a key has changed, leave the
known hosts entry intact, print a warning, and permit the connection
to proceed. This is the least secure value.</p></dd>



<dt><i><tt class="literal">ask</tt></i></dt>
<dd>Prompt the user. If a key is unknown, ask whether it should be added
to the user's database and whether to connect. If a key has
changed, ask whether to connect. This is the default and a sensible
value for knowledgeable users. (Less experienced users might not
understand what they're being asked and therefore may make the
wrong decision.)</p></dd>

</dl>



Here's an example:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
StrictHostKeyChecking yes</pre></blockquote>



<a href="ch07_04.html#ch07-55352">Table 7-1</a> summarizes SSH's
<tt class="literal">StrictHostKeyChecking</tt>'s behavior.</p>



<a name="ch07-55352" /><h4 class="objtitle">Table 7-1. StrictHostKeyChecking Behavior </h4><table border="1">





<tr>
<th>
Key Found?</p></th>
<th>
Match?</p></th>
<th>
Strict?</p></th>
<th>
Action</p></th>
</tr>






<tr>
<td>
Yes</p></td>
<td>
Yes</p></td>
<td>
-</p></td>
<td>
Connect</p></td>
</tr>


<tr>
<td>
Yes</p></td>
<td>
No</p></td>
<td>
Yes</p></td>
<td>
Warn and fail</p></td>
</tr>


<tr>
<td>
Yes</p></td>
<td>
No</p></td>
<td>
No</p></td>
<td>
Warn and connect</p></td>
</tr>


<tr>
<td>
Yes</p></td>
<td>
No</p></td>
<td>
Ask</p></td>
<td>
Warn and ask whether to connect</p></td>
</tr>


<tr>
<td>
No</p></td>
<td>
-</p></td>
<td>
Yes</p></td>
<td>
Warn and fail</p></td>
</tr>


<tr>
<td>
No</p></td>
<td>
-</p></td>
<td>
No</p></td>
<td>
Add key and connect</p></td>
</tr>


<tr>
<td>
No</p></td>
<td>
-</p></td>
<td>
Ask</p></td>
<td>
Ask whether to add key and to connect</p></td>
</tr>



</table><p>



OpenSSH has an additional keyword,
<tt class="literal">CheckHostIP</tt><a name="INDEX-1159" />,
to make a client verify the IP address of an SSH server in the
database. Its values may be <tt class="literal">yes</tt> (the default, to
verify the address) or <tt class="literal">no</tt>. The value
<tt class="literal">yes</tt> provides security against name service
spoofing attacks. [<a href="ch03_10.html#ch03-17239">Section 3.10.2, "Name Service and IP Spoofing"</a>]</p>



<blockquote><pre class="code"># OpenSSH only
CheckHostIP no</pre></blockquote>
</div>





<a name="ch07-15-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.3.2. Moving the known hosts files</h3>



SSH1 and OpenSSH permit the locations of the host key database, both
the serverwide and per-account parts, to be changed using
configuration keywords.
<tt class="literal">GlobalKnownHostsFile</tt><a name="INDEX-1160" />
defines an alternative location for the serverwide file. It
doesn't actually move the file -- only the system
administrator can do that -- but it does force your clients to use
another file in its place. This keyword is useful if the file is
outdated, and you want your clients to ignore the serverwide file,
particularly if you're tired of seeing warning messages from
your clients about changed keys.</p>



<blockquote><pre class="code"># SSH1, OpenSSH
GlobalKnownHostsFile /users/smith/.ssh/my_global_hosts_file</pre></blockquote>



Similarly, you can change the location of your per-user part of the
database with the keyword
<tt class="literal">UserKnownHostsFile</tt><a name="INDEX-1161" />:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
UserKnownHostsFile /users/smith/.ssh/my_local_hosts_file</pre></blockquote>
</div>
</div>








<a name="ch07-16-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.4. TCP/IP Settings</h3>



SSH uses TCP/IP as its transport mechanism. Most times you
don't need to change the default TCP settings, but in such
situations as the following, it's necessary:</p>



<ul><li>Connecting to SSH servers on other TCP ports</p></li><li>Using privileged versus nonprivileged ports</p></li><li>Keeping an idle connection open by sending keepalive messages</p></li><li><p>Enabling the Nagle Algorithm (TCP_NODELAY)</p></li><li><p>Requiring IP addresses to be Version 4 or 6</p></li></ul>
<a name="ch07-91208" /><div class="sect3">
<h3 class="sect3">7.4.4.1. Selecting a remote port</h3>



<a name="INDEX-1162" />Most SSH servers listen on TCP
<a name="INDEX-1163" />port 22, so
clients connect to this port by default. Nevertheless, sometimes you
need to connect to an SSH server on a different port number. For
example, if you are a system administrator testing a new SSH server,
you can run it on a different port to avoid interference with an
existing server. Then your clients need to connect to this alternate
port. This can be done with the client's
<tt class="literal">Port</tt><a name="INDEX-1164" />
keyword, followed by a port number:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
Port 2035</pre></blockquote>



or the <span class="option">-p</span> command-line option followed by the port
number:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -p 2035 server.example.com</pre></blockquote>



You can also specify an alternative port for <tt class="command">scp</tt>,
but the command-line option is <span class="option">-P</span> instead of
<span class="option">-p:</span><a href="#FOOTNOTE-96">[96]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-96" />[96]<tt class="command">scp</tt> also has
a <em class="emphasis">-p</em> option with the same meaning as for
<tt class="command">rcp </tt>: "preserve file
permissions."</p>


</blockquote>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ scp -P 2035 myfile server.example.com:</pre></blockquote>



In SSH2 2.1.0 and later, you can also provide a port number as part
of the user and host specification, preceded by a hash sign. For
example, the commands:</p>



<blockquote><pre class="code"># SSH2 only
$ ssh2 server.example.com#2035
$ ssh2 smith@server.example.com#2035
$ scp2 smith@server.example.com#2035:myfile localfile</pre></blockquote>



each create SSH-2 connections to remote port 2035. (We don't
see much use for this alternative syntax, but it's available.)</p>



After connecting to the server, <tt class="command">ssh</tt> sets an
environment variable in the remote shell to hold the port
information. For SSH1 and OpenSSH, the variable is called SSH_CLIENT,
and for SSH2 it is SSH2_CLIENT. The variable contains a string with
three values, separated by a space character: the client's IP
address, the client's TCP port, and the server's TCP
port. For example, if your client originates from port 1016 on IP
address 24.128.23.102, connecting to the server's port 22, the
value is:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
$ echo $SSH_CLIENT
24.128.23.102 1016 22

# SSH2 only
$ echo $SSH2_CLIENT
24.128.23.102 1016 22</pre></blockquote>



These variables are useful for scripting. In your shell's
startup file (e.g., <em class="filename">~/.profile</em>,
<em class="filename">~/.login</em>), you can test for the variable, and if
it exists, take actions. For example:</p>



<blockquote><pre class="code">#!/bin/sh
# Test for an SSH_CLIENT value of nonzero length
if [ -n "$SSH_CLIENT" ]
then
# We logged in via SSH.
  echo 'Welcome, SSH-1 user!'
  # Extract the IP address from SSH_CLIENT
  IP=`echo $SSH_CLIENT | awk '{print $1}'`
  # Translate it to a hostname.
  HOSTNAME=`host $IP | grep Name: | awk '{print $2}'`
  echo "I see you are connecting from $HOSTNAME."
else
  # We logged in not by SSH, but by some other means.
  echo 'Welcome, O clueless one. Feeling insecure today?'
fi</pre></blockquote>
</div>





<a name="ch07-17-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.4.2. Forcing a nonprivileged local port</h3>



<a name="INDEX-1165" /><a name="INDEX-1166" />SSH connections get locally
bound to a privileged TCP port, one whose port number is below 1024.
[<a href="ch03_04.html#ch03-19795">Section 3.4.2.3, "Trusted-host authentication (Rhosts and RhostsRSA)"</a>] If you ever need to override this
feature -- say, if your connection must pass through a firewall
that doesn't permit privileged source ports -- use the
<span class="option">-P</span> command-line option:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -P server.example.com</pre></blockquote>



The <span class="option">-P</span> option makes <tt class="command">ssh</tt> select a
local port that is nonprivileged.<a href="#FOOTNOTE-97">[97]</a> Let's watch this work by printing the value of
<a name="INDEX-1167" />SSH_CLIENT on the
remote machine, with and without <span class="option">-P</span>. Recall that
SSH_CLIENT lists the client IP address, client port, and server port,
in order.</p><blockquote class="footnote">


<a name="FOOTNOTE-97" />[97]Yes, it's
counterintuitive for <em class="emphasis">-P</em> to mean
<em class="emphasis">non</em>privileged, but that's life.</p>


</blockquote>



<blockquote><pre class="code"># Default: bind to privileged port.
$ ssh server.example.com 'echo $SSH_CLIENT'
128.119.240.87 1022 22                                   <i class="lineannotation">1022 &lt; 1024</i></pre></blockquote>



<blockquote><pre class="code"># Bind to non-privileged port.
$ ssh -P server.example.com 'echo $SSH_CLIENT'
128.119.240.87 36885 22                                  <i class="lineannotation">36885 &gt;= 1024</i></pre></blockquote>



The configuration keyword
<tt class="literal">UsePrivilegedPort</tt><a name="INDEX-1168" />
(SSH1, OpenSSH) has the same function as <span class="option">-P</span>, with
values <tt class="literal">yes</tt> (use a privileged port, the default)
and <tt class="literal">no</tt> (use a nonprivileged port):</p>



<blockquote><pre class="code"># SSH1, OpenSSH
UsePrivilegedPort no</pre></blockquote>



<tt class="command">scp</tt> also permits binding to nonprivileged ports
with these configuration keywords. However, the command-line options
are different from those of <tt class="command">ssh</tt>. For
<tt class="command">scp1</tt>, the option <span class="option">-L</span> means to bind
to a nonprivileged port, the same as setting
<tt class="literal">UsePrivilegedPort</tt> to
<tt class="literal">no</tt>:<a href="#FOOTNOTE-98">[98]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-98" />[98]The <em class="emphasis">-P</em>
option was already taken for setting the port number. The source code
suggests that <em class="emphasis">-L</em> can mean "large local
port numbers."</p>


</blockquote>



<blockquote><pre class="code"># SSH1 only
$ scp1 -L myfile server.example.com:</pre></blockquote>



<tt class="command">scp2</tt> has no command-line option for this feature.</p>



For trusted-host authentication you must use a privileged port. In
other words, if you use <span class="option">-P</span> or
<tt class="literal">UsePrivilegedPort</tt> <tt class="literal">no</tt>, you
disable <a name="INDEX-1169" />Rhosts and RhostsRSA
authentication. [<a href="ch03_04.html#ch03-19795">Section 3.4.2.3, "Trusted-host authentication (Rhosts and RhostsRSA)"</a>]</p>
</div>





<a name="ch07-18-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.4.3. Keepalive messages</h3>



The
<tt class="literal">KeepAlive</tt><a name="INDEX-1170" />
keyword instructs the client how to proceed if a connection problem
occurs, such as a prolonged network outage or a server machine crash:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
KeepAlive yes</pre></blockquote>



The value <tt class="literal">yes</tt> (the default) tells the client to
transmit and expect periodic <tt class="command">keepalive messages</tt>.
If the client detects a lack of responses to these messages, it shuts
down the connection. The value <tt class="literal">no</tt> means not to use
keepalive messages.</p>



Keepalive messages represent a tradeoff. If they are enabled, a
faulty connection is shut down, even if the problem is transient.
However, the TCP keepalive timeout on which this feature is based is
typically several hours, so this shouldn't be a big problem. If
keepalive messages are disabled, an unused faulty connection can
persist indefinitely.</p>



<tt class="literal">KeepAlive</tt> is generally more useful in the SSH
server, since a user sitting on the client side will certainly notice
if the connection becomes unresponsive. However, SSH can connect two
programs together, with the one running the SSH client waiting for
input from the other side. In such a situation, it can be necessary
to have a dead connection be eventually detected.</p>



<tt class="literal">KeepAlive</tt> isn't intended to deal with the
problem of SSH sessions being torn down because of firewall,
proxying, NAT, or IP masquerading timeouts. [<a href="ch05_04.html#ch05-64115">Section 5.4.3.4, "KeepAlive"</a>]</p>
</div>





<a name="ch07-70407" /><div class="sect3">
<h3 class="sect3">7.4.4.4. Controlling TCP_NODELAY</h3>



TCP/IP has a feature called the <a name="INDEX-1171" />Nagle Algorithm, an optimization for
reducing the number of TCP segments sent with very small amounts of
data. [<a href="ch04_01.html#ch04-29328">Section 4.1.5.3, "TCP/IP support"</a>] SSH2 clients may also enable or
disable the Nagle Algorithm using the
<tt class="literal">NoDelay</tt><a name="INDEX-1172" />
keyword:</p>



<blockquote><pre class="code"># SSH2 only
NoDelay yes</pre></blockquote>



Legal values are <tt class="literal">yes</tt> (to disable the algorithm)
and <tt class="literal">no</tt> (to enable it; the default).</p>
</div>





<a name="ch07-19-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.4.5. Requiring IPv4 and IPv6</h3>



OpenSSH can force its clients to use <a name="INDEX-1173" />Internet Protocol
Version 4 (IPv4) or 6 (IPv6) addresses. IPv4 is the current version
of IP used on the Internet; IPv6 is the future, permitting far more
addresses than IPv4 can support. For more information on these
address formats visit:</p>



<blockquote class="simplelist">

<a href="http://www.ipv6.org/">http://www.ipv6.org</a></p>

</blockquote>



To force IPv4 addressing, use the <span class="option">-4</span> flag:</p>



<blockquote><pre class="code"># OpenSSH only
$ ssh -4 server.example.com</pre></blockquote>



or likewise for IPv6, use <span class="option">-6 </span>:</p>



<blockquote><pre class="code"># OpenSSH only
$ ssh -6 server.example.com</pre></blockquote>
</div>
</div>








<a name="ch07-20-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.5. Making Connections</h3>



Under the best conditions, an SSH client attempts a secure
connection, succeeds, obtains your authentication credentials, and
executes whatever command you've requested, be it a shell or
otherwise. Various steps in this process are configurable, including:</p>



<ul><li>The number of times the client attempts the connection</p></li><li>The look and behavior of the password prompt (for password
authentication only)</p></li><li>Suppressing all prompting</p></li><li>Running remote commands interactively with a tty</p></li><li>Running remote commands in the background</p></li><li><p>Whether or not to fall back to an insecure connection, if a secure
one can't be established</p></li><li>The escape character for interrupting and resuming an SSH session</p></li></ul>
<a name="ch07-21-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.1. Number of connection attempts</h3>



<a name="INDEX-1174" />If you run an SSH1 or OpenSSH client and it
can't establish a secure connection, it will retry. By default,
it tries four times in rapid succession. You can change this behavior
with the keyword
<tt class="literal">ConnectionAttempts</tt><a name="INDEX-1175" />:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
ConnectionAttempts 10</pre></blockquote>



In this example, <tt class="command">ssh1</tt> tries 10 times before
admitting defeat, after which it either quits or falls back to an
insecure connection. We'll come back to this when we discuss
the keyword <tt class="literal">FallBackToRsh</tt>. [<a href="ch07_04.html#ch07-42679">Section 7.4.5.8, "RSH issues"</a>]</p>



Most people don't have much use for this keyword, but it might
be helpful if your network is unreliable. Just for fun, you can force
<tt class="command">ssh1</tt> to give up immediately by setting
<tt class="literal">ConnectionAttempts</tt> equal to zero:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
$ ssh -o ConnectionAttempts=0 server.example.com
Secure connection to server.example.com refused.</pre></blockquote>
</div>





<a name="ch07-22-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.2. Password prompting in SSH1</h3>



<a name="INDEX-1176" /><a name="INDEX-1177" />If you're using password
authentication in SSH1, clients prompt like this for your password:</p>



<blockquote><pre class="code">smith@server.example.com's password:</pre></blockquote>



You may tailor the appearance of this prompt. Perhaps for privacy
reasons, you might not want your username or hostname appearing on
the screen. The configuration keyword
<tt class="literal">PasswordPromptLogin</tt><a name="INDEX-1178" />,
with a value of <tt class="literal">yes</tt> (the default) or
<tt class="literal">no</tt>, prints or suppresses the username. For
example:</p>



<blockquote><pre class="code"># SSH1 only
PasswordPromptLogin no</pre></blockquote>



causes this prompt to appear without the username:</p>



<blockquote><pre class="code">server.example.com password:</pre></blockquote>



Likewise,
<tt class="literal">PasswordPromptHost</tt><a name="INDEX-1179" />
prints or suppresses the hostname, again with values of
<tt class="literal">yes</tt> (the default) or <tt class="literal">no</tt>. The
line:</p>



<blockquote><pre class="code"># SSH1 only
PasswordPromptHost no</pre></blockquote>



makes the prompt appear without the hostname:</p>



<blockquote><pre class="code">smith's password:</pre></blockquote>



If both keywords have value <tt class="literal">no</tt>, the prompt is
reduced to:</p>



<blockquote><pre class="code">Password:</pre></blockquote>



Remember, this applies only to password authentication. With
public-key authentication, the prompt for a passphrase is completely
different and not controlled by these keywords:</p>



<blockquote><pre class="code">Enter passphrase for RSA key 'Dave Smith's Home PC':</pre></blockquote>



You may also control the number of times you are prompted for your
password if mistyped. By default, you're prompted only once,
and if you mistype the password, the client exits. The keyword
<tt class="literal">NumberOfPasswordPrompts</tt><a name="INDEX-1180" />
may change this to between one and five prompts:<a href="#FOOTNOTE-99">[99]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-99" />[99]The
upper limit of five prompts is enforced by the SSH server.</p>


</blockquote>



<blockquote><pre class="code"># SSH1, OpenSSH
NumberOfPasswordPrompts 3</pre></blockquote>



Now your SSH clients provides three chances to type your password
correctly.</p>
</div>





<a name="ch07-23-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.3. Password prompting in SSH2</h3>



<a name="INDEX-1181" /><a name="INDEX-1182" />SSH2 adds
flexibility to password prompting. Instead of preset prompt strings,
you can design your own with the
<tt class="literal">PasswordPrompt</tt><a name="INDEX-1183" />
keyword:</p>



<blockquote><pre class="code"># SSH2 only
PasswordPrompt Enter your password right now, infidel:</pre></blockquote>



You can insert the remote username or hostname with the symbols
<tt class="literal">%U</tt> (remote username) or <tt class="literal">%H</tt>
(remote hostname). For example, to emulate the SSH1 prompt:</p>



<blockquote><pre class="code"># SSH2 only
PasswordPrompt "%U@%H's password:"</pre></blockquote>



Or you can be fancier:</p>



<blockquote><pre class="code"># SSH2 only
PasswordPrompt "Welcome %U! Please enter your %H password:"</pre></blockquote>
</div>





<a name="ch07-38751" /><div class="sect3">
<h3 class="sect3">7.4.5.4. Batch mode: suppressing prompts</h3>



<a name="INDEX-1184" /><a name="INDEX-1185" />In some cases, you
don't want to be prompted for your password or RSA passphrase.
If <tt class="command">ssh</tt> is invoked by an unattended shell script,
for example, nobody will be at the keyboard to type a password. This
is why SSH <tt class="command">batch mode</tt> exists. In batch mode, all
prompting for authentication credentials is suppressed. The keyword
<tt class="literal">BatchMode</tt><a name="INDEX-1186" />
can have a value of <tt class="literal">yes</tt> (disable prompting) or
<tt class="literal">no</tt> (the default, with prompting enabled):</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
BatchMode yes</pre></blockquote>



Batch mode may enabled for <tt class="command">scp</tt> also with the
<span class="option">-B</span> option:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ scp1 -B myfile server.example.com:</pre></blockquote>



Batch mode doesn't replace authentication. If a password or
passphrase is required, you can't magically log in without it
by suppressing the prompt. If you try, your client exits with an
error message such as "permission denied." In order for
batch mode to work, you must arrange for authentication to work
without a password/passphrase, say, with trusted-host authentication
or an SSH agent. [<a href="ch11_01.html#ch11-57817">Section 11.1, "Unattended SSH: Batch or cron Jobs"</a>]</p>
</div>





<a name="ch07-56319" /><div class="sect3">
<h3 class="sect3">7.4.5.5. Pseudo-terminal allocation (TTY/PTY/PTTY)</h3>



<a name="INDEX-1187" /><a name="INDEX-1188" />A Unix <em class="emphasis">tty
</em>(pronounced as it's spelled, T-T-Y) is a software
abstraction representing a computer terminal, originally an
abbreviation for "teletype." As part of an interactive
session with a Unix machine, a tty is allocated to process keyboard
input, limit screen output to a given number of rows and columns, and
handle other terminal-related activities. Since most terminal-like
connections don't involve an actual hardware terminal, but
rather a window, a software construct called a
<em class="emphasis">pseudo-tty</em> (or <em class="emphasis">pty,
</em>pronounced P-T-Y) handles this sort of connection.</p>



When a client requests an SSH connection, the server doesn't
necessarily allocate a pty for the client. It does so, of course, if
the client requests an interactive terminal session, e.g., just
<tt class="command">ssh host</tt>. But if you ask <tt class="command">ssh</tt> to
run a simple command on a remote server, such as <tt class="command">ls
</tt>:</p>



<blockquote><pre class="code">$ ssh remote.server.com /bin/ls</pre></blockquote>



<a name="INDEX-1189" />no interactive terminal session
is needed, just a quick dump of the output of <tt class="command">ls</tt>.
In fact, by default <tt class="command">sshd</tt> doesn't allocate a
pty for such a command. On the other hand, if you try running an
interactive command like the text editor Emacs in this manner, you
get an error message:</p>



<blockquote><pre class="code">$ ssh remote.server.com emacs -nw
emacs: standard input is not a tty</pre></blockquote>



because Emacs is a screen-based program intended for a terminal. In
such cases, you can request that SSH allocate a pty using the
<span class="option">-t</span> option:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -t server.example.com emacs</pre></blockquote>



SSH2 also has the keyword
<tt class="literal">ForcePTTYAllocation</tt><a name="INDEX-1190" />,
which does the same thing as <span class="option">-t </span>.<a href="#FOOTNOTE-100">[100]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-100" />[100]In
SSH1 and OpenSSH, the <tt class="literal">no-pty</tt> option in
<em class="filename">authorized_keys </em>can override this request for a
tty. [<a href="ch08_02.html#ch08-38676">Section 8.2.9, "Disabling TTY Allocation"</a>]</p>


</blockquote>



If SSH allocates a pty, it also automatically defines an environment
variable in the remote shell. The variable is
<a name="INDEX-1191" /><a name="INDEX-1192" />SSH_TTY (for SSH1 and
OpenSSH) or SSH2_TTY (for SSH2) and contains name of the character
device file connected to the "slave" side of the pty, the
side that emulates a real tty. We can see this in action with a few
simple commands. Try printing the value of SSH_TTY on a remote
machine. If no tty is allocated, the result is blank:</p>



<blockquote><pre class="code">$ ssh1 server.example.com 'echo $SSH_TTY'
<i class="lineannotation">[no output]</i></pre></blockquote>



If you force allocation, the result is the name of the tty:</p>



<blockquote><pre class="code">$ ssh1 -t server.example.com 'echo $SSH_TTY'
/dev/pts/1</pre></blockquote>



Thanks to this variable, you can run shell scripts on the remote
machine that use this information. For example, here's a script
that runs your default editor only if a terminal is available:</p>



<blockquote><pre class="code">#!/bin/sh
if [ -n $SSH_TTY -o -n $SSH2_TTY ]; then
   echo 'Success!'
   exec $EDITOR 
else
   echo "Sorry, interactive commands require a tty"
fi</pre></blockquote>



Place this script in your remote account, calling it
<tt class="command">myscript</tt> (or whatever), and run:</p>



<blockquote><pre class="code">$ ssh server.example.com myscript
Sorry, interactive commands require a tty
$ ssh -t server.example.com myscript
Success!
<i class="lineannotation">...Emacs runs...</i></pre></blockquote>
</div>





<a name="ch07-24-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.6. Backgrounding a remote command</h3>



If you try running an SSH <a name="INDEX-1193" /><a name="INDEX-1194" />remote
command in the background, you might be surprised by the result.
After the remote command runs to completion, the client automatically
suspends before the output is printed:</p>



<blockquote><pre class="code">$ ssh server.example.com ls &amp;
[1]  11910
$
<i class="lineannotation">... time passes ...</i>
[1] + Stopped (SIGTTIN)        ssh server.example.com ls &amp;</pre></blockquote>



This happens because <tt class="command">ssh</tt> is attempting to read
from standard input while in the background, which causes the shell
to suspend <tt class="command">ssh</tt>. To see the resulting output, you
must bring <tt class="command">ssh</tt> into the foreground:</p>



<blockquote><pre class="code">$ fg
README
myfile
myfile2</pre></blockquote>



<tt class="command">ssh</tt> provides the <span class="option">-n</span> command-line
option to get around this problem. It redirects standard input to
come from <em class="filename">/dev/null</em>, which prevents
<tt class="command">ssh</tt> from blocking for input. Now when the remote
command finishes, the output is printed immediately:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -n server.example.com ls &amp;
[1]  11912
$
<i class="lineannotation">... time passes ...</i>
README
myfile
myfile2</pre></blockquote>



SSH2 has a keyword
<tt class="literal">DontReadStdin</tt><a name="INDEX-1195" /> that does the same thing as
<span class="option">-n</span>, accepting the values <tt class="literal">yes</tt> or
<tt class="literal">no</tt> (the default is <tt class="literal">no</tt>):</p>



<blockquote><pre class="code"># SSH2 only
DontReadStdin yes</pre></blockquote>
</div>





<a name="ch07-25-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.7. Backgrounding a remote command, take two</h3>



The preceding section assumed you didn't need to type a
password or passphrase, e.g., that you're running an SSH agent.
What happens if you use <span class="option">-n</span> or
<tt class="literal">DontReadStdin</tt> but the
<a name="INDEX-1196" /><a name="INDEX-1197" />SSH
client needs to read a password or passphrase from you?</p>



<blockquote><pre class="code">$ ssh -n server.example.com ls &amp;
$
Enter passphrase for RSA key 'smith@client':</pre></blockquote>



<a name="ch07-26-fm2xml" /><blockquote><b>WARNING: </b>
STOP! Don't type your passphrase! Because the command is run in
the background with <em class="emphasis">-n</em>, the prompt is also
printed in the background. If you respond, you will be typing to the
shell, not the <tt class="command">ssh</tt> prompt, and anything you type
will be visible.</p>


</blockquote>

You need a solution that not only disables input and sends the
process into the background, but also permits <tt class="command">ssh</tt>
to prompt you. This is the purpose of the <span class="option">-f</span>
command-line option, which instructs <tt class="command">ssh</tt> to do the
following in order:</p>



<ol><li>Perform authentication, including any prompting</p></li><li>Cause the process to read from <em class="filename">/dev/null</em>,
exactly like <span class="option">-n</span></p></li><li>Put the process into the background: no "&amp;" is needed</p></li></ol>
Here's an example:</p>



<blockquote><pre class="code">$ ssh -f server.example.com ls
Enter passphrase for RSA key 'smith@client': <tt class="userinput"><b>********</b></tt>
$
<i class="lineannotation">... time passes...</i>
README
myfile
myfile2</pre></blockquote>



SSH2 has a keyword
<tt class="literal">GoBackground</tt><a name="INDEX-1198" />
that does the same thing, accepting the values <tt class="literal">yes</tt>
or <tt class="literal">no</tt> (the default):</p>



<blockquote><pre class="code"># SSH2 only
GoBackground yes</pre></blockquote>



<tt class="literal">GoBackground</tt> and <span class="option">-f</span> also set up
any port forwardings you may have specified on the command line.
[<a href="ch09_02.html#ch09-95987">Section 9.2.6, "Port Forwarding Without a Remote Login"</a>] The setup occurs after authentication
but before backgrounding.</p>
</div>





<a name="ch07-42679" /><div class="sect3">
<h3 class="sect3">7.4.5.8. RSH issues</h3>



<a name="INDEX-1199" />Suppose a remote host
isn't running an SSH server, but you try to log into it via
SSH. What happens? Depending on your client configuration settings,
three scenarios can occur:</p>



<dl>
<dt><i>Scenario 1</i></dt>
<dd><tt class="command">ssh</tt> attempts an SSH connection, fails, and then
attempts an insecure <tt class="command">rsh</tt> connection.<a href="#FOOTNOTE-101">[101]</a> This is the default behavior, and it's a sensible
guess of what a user might have done anyway. ("Hmm, I
can't connect by SSH. I'll try <tt class="command">rsh</tt>
instead.") The connection attempt displays:</p><blockquote class="footnote">


<a name="FOOTNOTE-101" />[101]Only if <tt class="command">ssh </tt>is compiled with support for
<tt class="command">rsh</tt>, using the compile-time flag
<tt class="literal">--with-rsh</tt>. [<a href="ch04_01.html#ch04-99797">Section 4.1.5.12, "R-commands (rsh) compatibility"</a>] If not,
Scenario 2, fail and stop, is the only possibility.</p>


</blockquote>



<blockquote><pre class="code">$ ssh no-ssh-server.com
Secure connection to no-ssh-server.com on port 22 refused; reverting to insecure method.
Using rsh.  WARNING: Connection will not be encrypted.</pre></blockquote></dd>



<dt><i>Scenario 2</i></dt>
<dd><tt class="command">ssh</tt> attempts an SSH connection, fails, and stops.
This behavior is best for security-conscious installations where
<tt class="command">rsh</tt> is simply not acceptable.</p>



<blockquote><pre class="code">$ ssh no-ssh-server.com
Secure connection to no-ssh-server.com on port 22 refused.</pre></blockquote></dd>



<dt><i>Scenario 3</i></dt>
<dd>Rather than attempt an SSH connection at all, <tt class="command">ssh</tt>
immediately attempts an insecure <tt class="command">rsh</tt>
connection.<a href="#FOOTNOTE-102">[102]</a> This is best if you know in advance that certain
machines don't run SSH servers, and you find
<tt class="command">rsh</tt> acceptable.</p><blockquote class="footnote">


<a name="FOOTNOTE-102" />[102]Again, only if <tt class="command">ssh </tt>is
compiled with <tt class="literal"> -- with-rsh</tt>.</p>


</blockquote>



<blockquote><pre class="code">$ ssh no-ssh-server.com
Using rsh.  WARNING: Connection will not be encrypted.</pre></blockquote></dd>

</dl>


Two configuration keywords select the behavior you prefer. (And
remember, you can configure them separately for each remote host you
want to visit.)
<tt class="literal">FallBackToRsh</tt><a name="INDEX-1200" />
controls what happens when an SSH connection attempt fails: should it
then try an <tt class="command">rsh</tt> connection or not?
<tt class="literal">FallBackToRsh</tt> may have the value
<tt class="literal">yes</tt> (the default, to try <tt class="command">rsh</tt>)
or <tt class="literal">no</tt> (don't try <tt class="command">rsh</tt>):</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
FallBackToRsh no</pre></blockquote>



The keyword
<tt class="literal">UseRsh</tt><a name="INDEX-1201" />
instructs <tt class="command">ssh</tt> to use <tt class="command">rsh</tt>
immediately, not even attempting an SSH connection. Permissible
values are <tt class="literal">yes</tt> (to use <tt class="command">rsh</tt>) and
<tt class="literal">no</tt> (the default, to use <tt class="command">ssh</tt>):</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
UseRsh yes</pre></blockquote>



Therefore, here is how to create these three scenarios:.</p>



<dl>
<dt><i>Scenario 1: Try <tt class="command">ssh</tt> first, then fall back to <tt class="command">rsh</tt></i></dt>
<dd><blockquote><pre class="code"># SSH1, SSH2, OpenSSH
FallBackToRsh yes
UseRsh no</pre></blockquote></dd>



<dt><i>Scenario 2: Use ssh only</i></dt>
<dd><blockquote><pre class="code"># SSH1, SSH2, OpenSSH
FallBackToRsh no
UseRsh no</pre></blockquote></dd>



<dt><i>Scenario 3: Use <tt class="command">rsh</tt> only</i></dt>
<dd><blockquote><pre class="code"># SSH1, SSH2, OpenSSH
UseRsh yes</pre></blockquote></dd>

</dl>


Please be careful with the <tt class="literal">UseRsh</tt> keyword. Make
sure to limit its effects to individual remote hosts in your
configuration file, not to all hosts. The following table depicts an
example that can disable encryption for all your SSH connections:</p>



<a name="ch07-27-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code"># Never do this! Security risk!!
Host *
 UseRsh yes</pre></blockquote></td>
<td>
<blockquote><pre class="code"># Never do this! Security risk!!
*:
 UseRsh yes</pre></blockquote></td>
</tr>



</table><p>
</div>





<a name="ch07-28-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.5.9. Escaping</h3>



Recall that the <tt class="command">ssh</tt> client has an <tt class="command">escape
sequence</tt><a name="INDEX-1202" /> feature. [<a href="ch02_03.html#ch02-71033">Section 2.3.2, "The Escape Character"</a>] By typing a particular character, normally a
tilde (~), immediately after a newline or carriage return, you can
send special commands to <tt class="command">ssh</tt>: terminate the
connection, suspend the connection, and so forth. But sometimes the
default escape character can cause a problem.</p>



Suppose you connect by ssh from host A to host B, then from host B to
host C, and finally from host C to host D, making a chain of
<em class="filename">ssh</em> connections. (We represent the
machines' shell prompts as A$, B$, C$, and D$.)</p>



<blockquote><pre class="code">A$ ssh B
...
  B$ ssh C
  ...
    C$ ssh D
    ...
      D$</pre></blockquote>



While logged onto host D, you press the Return key, then
<tt class="literal">~ ^Z</tt> (tilde followed by
<tt class="literal">Control-Z</tt>) to suspend the connection temporarily.
Well, you've got three <tt class="command">ssh</tt> connections
active, so which one gets suspended? The first one does, and this
escape sequence brings you back to the host A prompt. Well, what if
you want to escape back to host B or C ? There are two methods, one
with forethought and one on the spur of the moment.</p>



If you prepare in advance, you may change the escape character for
each connection with the configuration keyword
<tt class="literal">EscapeChar</tt><a name="INDEX-1203" />,
followed by a character:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
EscapeChar %</pre></blockquote>



or the <span class="option">-e</span> command-line option, followed again by the
desired character (quoted if necessary to protect it from expansion
by the shell):</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -e '%' server.example.com</pre></blockquote>



So, going back to our example of hosts A through D, you want a
different escape character for each segment of this chain of
connections. For example,</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
A$ ssh B
...
  B$ ssh -e '$' C
  ...
    C$ ssh -e '%' D
    ...
      D$</pre></blockquote>



Now, while logged onto host D, a tilde still brings you back to host
A, but a dollar sign brings you back to host B, and a percent sign
back to host C. The same effect can be achieved with the
<tt class="literal">EscapeChar</tt> keyword, but the following table shows
that more forethought is required to set up configuration files on
three hosts.</p>



<a name="ch07-29-fm2xml" /><table border="1">



<tr>
<th>
SSH1, OpenSSH</p></th>
<th>
SSH2</p></th>
</tr>






<tr>
<td>
<blockquote><pre class="code"># Host A configuration file
Host B
 EscapeChar ~

# Host B configuration file
Host C
 EscapeChar ^

# Host C configuration file 
Host D
 EscapeChar %</pre></blockquote></td>
<td>
<blockquote><pre class="code"># Host A configuration file
B:
 EscapeChar ~

# Host B configuration file
C:
 EscapeChar ^

# Host C configuration file
D:
 EscapeChar %</pre></blockquote></td>
</tr>



</table><p>

Even if you don't normally make chains of SSH connections, you
might still want to change the escape character. For example, your
work might require you to type a lot of tildes for other reasons, and
you might accidentally type an escape sequence such as
<tt class="literal">~.</tt> (tilde period) and disconnect your session.
Oops!</p>



The second method requires no forethought. Recall that typing the
escape character twice sends it <a name="INDEX-1204" /><a name="INDEX-1205" />literally across the SSH connection.
[<a href="ch02_03.html#ch02-71033">Section 2.3.2, "The Escape Character"</a>] Therefore, you can suspend the second
SSH connection by typing two escapes, the third by typing three
escapes, and so on. Remember you must precede your escape characters
by pressing the Return key. While logged onto host D, you could
escape back to host B, for example, by hitting the Return key, then
typing two tildes, and <tt class="literal">Control-Z</tt>.</p>
</div>
</div>








<a name="ch07-84884" /><div class="sect2">
<h3 class="sect2">7.4.6. Proxies and SOCKS</h3>



<a name="INDEX-1206" />SOCKS is an
application-layer network proxying system supported by various SSH
implementations. Proxying in general provides a way to connect two
networks at the application level, without allowing direct
network-level connectivity between them. <a href="ch07_04.html#ch07-60463">Figure 7-3</a>
shows a typical SOCKS installation.</p>



<a name="ch07-60463" /><div class="figure"><img height="181" alt="Figure 7-3" src="figs/ssh_0703.gif" width="481" /></div><h4 class="objtitle">Figure 7-3. A typical SOCKS installation</h4>

The figure shows a private network and the Internet. The gateway
machine is connected to both, but doesn't function as a router;
there's no direct IP connectivity between the two networks. If
a program running on H wants to make a TCP connection to a server on
S, it instead connects to the SOCKS server running on G. Using the
SOCKS protocol, H requests a connection to S. The SOCKS server makes
a connection from G to S on behalf of H and then steps out of the
way, passing data back and forth between H and S.</p>



A general drawback of application-level proxying is lack of
transparency: only those programs written with support for the
particular proxying scheme have network access. SOCKS, however,
isn't specific to any higher-level protocol such as HTTP or
SMTP. It provides general services: makes a TCP connection, pings a
host, performs a traceroute, etc. Many of its services match the
existing programming boundary between applications and
network-services libraries. As a result, on modern computer systems
employing dynamically linked libraries, it is often possible to
extend SOCKS to non-SOCKS-aware applications, such as SSH, by
replacing the right libraries with SOCKS-aware ones.</p>



SOCKS comes in two versions, SOCKS4 and SOCKS5. The major difference
between them is that SOCKS5 performs user authentication, whereas
SOCKS4 doesn't. With SOCKS5, you can require the client to
provide a username and password (or other authentication schemes)
before accessing its network services.</p>



<a name="ch07-30-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.6.1. SOCKS in SSH1</h3>



<a name="INDEX-1207" />The
following description assumes you've installed SSH1 with SOCKS
support, using the NEC <tt class="command">socks5</tt> package. [<a href="ch04_01.html#ch04-96817">Section 4.1.5.8, "SOCKS proxy support"</a>] If you use a different package, the
SOCKS-specific configuration details may differ from those we
describe.</p>



By the way, the names are a little confusing. Even though the NEC
software is named "socks5," it implements both the SOCKS4
and SOCKS5 protocols. We write "socks5" in lowercase to
refer to the NEC implementation.</p>



Once you've installed your SOCKS-aware <tt class="command">ssh</tt>,
you can control its SOCKS-related behavior using
<a name="INDEX-1208" />environment
variables. By default, <tt class="command">ssh</tt> doesn't use SOCKS
at all. If you set
<a name="INDEX-1209" />SOCKS_SERVER to
"socks.shoes.com", <tt class="command">ssh</tt> uses the SOCKS
gateway running on <em class="emphasis">socks.shoes.com</em> for any connection to an
SSH server outside the local host's subnet (as defined by
netmask setting on the relevant network interface). If you want
<tt class="command">ssh</tt> to use SOCKS for all connections, even
local-subnet ones, set the variable
<a name="INDEX-1210" />SOCKS5_NONETMASKCHECK.
If your SOCKS gateway requires username/password authentication, set
the variables
<a name="INDEX-1211" />SOCKS5_USER and
<a name="INDEX-1212" />SOCKS5_PASSWD
with your username and password. SOCKS-specific debugging output is
available by setting environment variables:</p>



<blockquote><pre class="code">#!/bin/csh
setenv SOCKS5_DEBUG 3
setenv SOCKS5_LOG_STDERR</pre></blockquote>



The documentation mentions debugging levels only up to 3, but in fact
the code uses higher ones that are sometimes crucial to understanding
a problem. Try cranking up the value if you're not getting
enough information.</p>
</div>





<a name="ch07-31-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.6.2. SOCKS in SSH2</h3>



<a name="INDEX-1213" />SSH2
provides SOCKS4 support only. It is integrated into the SSH2 code, so
you don't need to install a separate SOCKS package. You also
don't need to enable SOCKS specifically when compiling; it is
always included.</p>



The SSH2 SOCKS feature is controlled with a single parameter, set
with the
<tt class="literal">SocksServer</tt><a name="INDEX-1214" />
configuration keyword or the
<a name="INDEX-1215" />SSH_SOCKS_SERVER
environment variable. The configuration option overrides the
environment variable if both are present.</p>



The
<tt class="literal">SocksServer</tt><a name="INDEX-1216" />
keyword is a string with the following format:</p>



<blockquote><pre class="code">socks://[<em class="replaceable">user</em>]@<em class="replaceable">gateway</em>[:<em class="replaceable">port</em>]/[<em class="replaceable">net1/mask1</em>,<em class="replaceable">net2/mask2</em>,<em class="replaceable">...</em>]</pre></blockquote>



Here, <em class="emphasis">gateway</em> is the machine running the SOCKS
server, <em class="emphasis">user</em> is the username you supply for
identification to SOCKS, and <em class="emphasis">port</em> is the TCP
port for the SOCKS server (by default, 1080). The <em class="emphasis">net/mask
</em>entries indicate netblocks that are to be considered
local; that is, <tt class="command">ssh2</tt> uses SOCKS only for
connections lying outside the given network ranges. The mask is given
as a number of bits, not an explicit mask, i.e., 192.168.10.0/24
instead of 192.168.10.0/255.255.255.0.</p>



The parts of the string enclosed in square brackets are optional. So
an SSH_SOCKS_SERVER value can be as simple as this:</p>



<blockquote><pre class="code">socks://laces.shoes.net</pre></blockquote>



With this value, <tt class="command">ssh2</tt> uses SOCKS for all
connections. It connects to a SOCKS server running on <em class="emphasis">laces.shoes.net</em>, port 1080, and it
doesn't supply a username. You might wonder why there's a
username but no password field. Recall that SOCKS4 doesn't
support user authentication. The username is advisory only; the SOCKS
server has no way of verifying your claimed identity.</p>



You'll probably never want to use an SSH_SOCKS_SERVER setting
as simple as this one, which uses the SOCKS server for all
<tt class="command">ssh2</tt> connections, even those connecting back to
the same machine or to a machine on the same network. A better setup
is to use SOCKS only for hosts on the other side of the gateway from
you. Here's a more complete example:</p>



<blockquote><pre class="code">socks://dan@laces.shoes.net:4321/127.0.0.0/8,192.168.10.0/24</pre></blockquote>



With this value, <tt class="command">ssh2</tt> connects directly to itself
via its loopback address (127.0.0.1), or to hosts on the class C
network 192.168.10.0. It uses SOCKS for all other connections,
supplying the username "dan" and looking for the SOCKS
server on port 4321.</p>
</div>





<a name="ch07-32-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.6.3. SOCKS in OpenSSH</h3>



<a name="INDEX-1217" />OpenSSH
doesn't include explicit support for SOCKS. However, we have
found that it works just fine with the
<tt class="command">runsocks</tt><a name="INDEX-1218" /> program supplied with NEC's
SOCKS5 package. <tt class="command">runsocks</tt> is a wrapper that
rearranges dynamic linking order so that sockets routines such as
<tt class="function">bind</tt>, <tt class="function">connect</tt>, etc., are
replaced by SOCKS-ified versions at runtime. On a Linux system, we
found that setting the appropriate <tt class="command">socks5</tt>
environment variables as discussed earlier, and then running:</p>



<blockquote><pre class="code">% runsocks ssh ...</pre></blockquote>



caused OpenSSH to work seamlessly through our SOCKS server. One
caveat, though: in order to work, the OpenSSH client must not be
setuid. For obvious security reasons, shared-library loaders ignore
the shenanigans of <tt class="command">runsocks</tt> if the executable in
question is setuid. And remember that setuid is required for
trusted-host authentication. [<a href="ch03_04.html#ch03-19795">Section 3.4.2.3, "Trusted-host authentication (Rhosts and RhostsRSA)"</a>]</p>



At one time, there was some code in OpenSSH for SOCKS support.
However, it was removed and replaced by a recommendation to use the
<tt class="literal">ProxyCommand</tt><a name="INDEX-1219" />
feature instead. The idea is to have a little program that just takes
a hostname and port number on the command line, connects to that
socket via SOCKS, then acts as a pipe, passing data back and forth
between the TCP connection and its standard input and output. If this
program were called <tt class="command">ssh-proxy,</tt> it can be used with
OpenSSH like so:</p>



<blockquote><pre class="code">% ssh -o 'ProxyCommand ssh-proxy %h %p' ...</pre></blockquote>



This still doesn't work with SSH1 RhostsRSA authentication
unless <tt class="command">ssh-proxy</tt> is setuid root and written to use
a privileged source port. It doesn't by itself interfere with
SSH2 hostbased authentication, but it has a separate problem. [<a href="ch07_04.html#ch07-44068">Section 7.4.6.4, "Other SOCKS issues"</a>]</p>



We're sure such a SOCKS proxying widget must be available
somewhere, but we haven't turned one up. You can't use
the SOCKS-ified <tt class="command">telnet</tt> that comes with
<tt class="command">socks5</tt> because it isn't transparent; bytes
in the binary SSH protocol stream are interpreted as Telnet escape
sequences and are munged. The authors did prove the concept, though,
by taking a copy of <tt class="command">netcat</tt> (<a href="http://www.l0pht.com/~weld/netcat/">http://www.l0pht.com/~weld/netcat/</a>), and
SOCKS-ifying it by linking against the <tt class="command">socks5</tt>
libraries. The <tt class="command">netcat</tt> executable is named
<tt class="command">nc</tt>; using our altered version, the following
worked for us, sending the SSH connection through our SOCKS gateway:</p>



<blockquote><pre class="code">% ssh -o 'ProxyCommand nc %h %p' ...</pre></blockquote>



Perhaps the OpenSSH folks will see fit to include such a utility at
some point.</p>
</div>





<a name="ch07-44068" /><div class="sect3">
<h3 class="sect3">7.4.6.4. Other SOCKS issues</h3>



Keep in mind that an SSH connection through SOCKS appears to come
from the SOCKS gateway, not from the originating client host. This
causes a problem with
<a name="INDEX-1220" />trusted-host
authentication. <tt class="command">sshd1</tt> uses the source IP address
of the connection to look up the client's host key, so
RhostsRSA authentication will fail: it expects the gateway's
host key, not that of the real client. You can get around this only
by giving all the clients the same host key and associating that with
the gateway in the SSH server's known-hosts database.
That's not such a great arrangement, since if one host key is
stolen, the thief can masquerade as any user on any of the clients,
not just one. But it might be acceptable in some situations.</p>



With SSH2, the problem should be gone; the SSH-2 protocol makes
hostbased authentication independent of the client host address.
However, SSH2 still implements it the old way, which still
doesn't work through SOCKS. You might be tempted simply to
disable the address/name check yourself in the source code.
Don't do it. The issue is slightly more complicated. [<a href="ch03_05.html#ch03-80181">Section 3.5.1.6, "Hostbased authentication"</a>]</p>
</div>
</div>








<a name="ch07-33-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.7. Forwarding</h3>



Port forwarding and X forwarding are covered in <a href="ch09_01.html">Chapter 9, "Port Forwarding and X Forwarding"</a> and agent forwarding in <a href="ch06_01.html">Chapter 6, "Key Management and Agents"</a>. We mention them here only for completeness,
since forwarding can be controlled in the client configuration file
and on the command line.</p>
</div>








<a name="ch07-34-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.8. Encryption Algorithms</h3>



<a name="INDEX-1221" /><a name="INDEX-1222" />When
establishing a connection, an SSH client and server have a little
conversation about encryption. The server says, "Hello client,
here are the encryption algorithms I support." In return, the
client says, "Hi there server, I'd like to choose this
particular algorithm, please." Normally, they reach agreement,
and the connection proceeds. If they can't agree on an
encryption algorithm, the connection fails.</p>



Most users let the client and server work things out themselves. But
if you like, you may instruct the client to request particular
encryption algorithms in its conversation with the server. In SSH1
and OpenSSH, this is done with the
<tt class="literal">Cipher</tt><a name="INDEX-1223" />
keyword followed by your encryption algorithm of choice:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
Cipher blowfish</pre></blockquote>



or the <span class="option">-c</span> command-line option:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -c blowfish server.example.com
$ scp -c blowfish myfile server.example.com:</pre></blockquote>



SSH2 is almost the same, but the keyword is
<tt class="literal">Ciphers</tt><a name="INDEX-1224" />
(note the final "s") and is followed by one or more
encryption algorithms, separated by commas, indicating that any of
these algorithms is acceptable:</p>



<blockquote><pre class="code"># SSH2, OpenSSH/2
Ciphers blowfish,3des</pre></blockquote>



SSH2 also supports the <span class="option">-c</span> command-line option as
previously, but it may appear multiple times to specify several
acceptable ciphers:</p>



<blockquote><pre class="code"># SSH2 only
$ ssh2 -c blowfish -c 3des -c idea server.example.com
$ scp2 -c blowfish -c 3des -c idea myfile server.example.com:</pre></blockquote>



OpenSSH/2 permits multiple algorithms to follow a single
<span class="option">-c</span>, separated by commas, to achieve the same effect:</p>



<blockquote><pre class="code"># OpenSSH/2 only
$ ssh -c 3des-cbc,blowfish-cbc,arcfour server.example.com</pre></blockquote>



All ciphers acceptable by a server may be specified for the client.
[<a href="ch05_04.html#ch05-67370">Section 5.4.5, "Encryption Algorithms"</a>] Check the latest SSH documentation for a
current list of supported ciphers.</p>



<a name="ch07-35-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.8.1. MAC algorithms</h3>



<a name="INDEX-1225" />The <span class="option">-m</span> command-line
option lets you select the integrity-checking algorithm, known as the
MAC (Message Authentication Code), used by <tt class="command">ssh2 </tt>:
[<a href="ch03_09.html#ch03-39382">Section 3.9.3, "Hash Functions"</a>]</p>



<blockquote><pre class="code"># SSH2 only
$ ssh2 -m hmac-sha1 server.example.com</pre></blockquote>



You can specify multiple algorithms on the command line, each
preceded by a separate <span class="option">-m</span> option:</p>



<blockquote><pre class="code"># SSH2 only
$ ssh2 -m hmac-sha1 -m another-one server.example.com</pre></blockquote>



and the SSH2 server selects one to use.</p>
</div>
</div>








<a name="ch07-36-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.9. Session Rekeying</h3>



The
<tt class="literal">RekeyIntervalSeconds</tt><a name="INDEX-1226" />
keyword specifies how often (in seconds) the SSH2 client performs key
exchange with the server to replace the session data-encryption and
integrity keys. The default is 3600 seconds (one hour), and a zero
value disables rekeying:<a href="#FOOTNOTE-103">[103]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-103" />[103]Note that at press time, you
must disable session rekeying in the SSH2 client if you wish to use
it with the OpenSSH server, because the latter doesn't yet
support session rekeying. The connection dies with an error once the
rekeying interval expires. This feature will likely be implemented
soon, however.</p>


</blockquote>



<blockquote><pre class="code"># SSH2 only
RekeyIntervalSeconds 7200</pre></blockquote>
</div>








<a name="ch07-37-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.10. Authentication</h3>



<a name="INDEX-1227" /><a name="INDEX-1228" />In a typical SSH setup, clients
try to authenticate by the strongest methods first. If a particular
method fails or isn't set up, the next one is tried, and so on.
This default behavior should work fine for most needs.</p>



Nevertheless, your clients may request specific types of
authentication if they need to do so. For example, you might want to
use public-key authentication only, and if it fails, no other methods
should be tried.</p>



<a name="ch07-38-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.10.1. Requesting an authentication technique</h3>



SSH1 and OpenSSH clients can request specific authentication methods
by keyword. The syntax is the same as the server's in
<em class="filename">/etc/sshd_config</em>. [<a href="ch05_05.html#ch05-46136">Section 5.5.1, "Authentication"</a>]
You can specify:</p>



<blockquote class="simplelist">

<tt class="literal">PasswordAuthentication</tt></p>

<tt class="literal">RhostsAuthentication</tt></p>

<tt class="literal">RhostsRSAAuthentication</tt></p>

<tt class="literal">RSAAuthentication</tt> </p>

<tt class="literal">TISAuthentication</tt></p>

<tt class="literal">KerberosAuthentication</tt></p>

</blockquote>



(The latter two keywords require TIS or Kerberos support compiled in,
respectively.) Any or all of these keywords may appear with the value
<tt class="literal">yes</tt> or <tt class="literal">no</tt>.</p>



For SSH2, the <tt class="literal">AllowedAuthentications</tt> keyword
selects one or more authentication techniques. Again, the keyword has
the same use here as for the SSH2 server. [<a href="ch05_05.html#ch05-46136">Section 5.5.1, "Authentication"</a>]</p>



OpenSSH accepts the same keywords as SSH1 except for
<tt class="literal">TISAuthentication</tt>, and it adds
<tt class="literal">SkeyAuthentication</tt> for one-time passwords. [<a href="ch05_05.html#ch05-81830">Section 5.5.1.10, "S/Key authentication"</a>]</p>
</div>





<a name="ch07-39-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.10.2. The server is the boss</h3>



When a client specifies an authentication technique, this is just a
request, not a requirement. For example, the configuration:</p>



<blockquote><pre class="code">PasswordAuthentication yes</pre></blockquote>



informs the SSH server that you, the client, agree to participate in
password authentication. It doesn't guarantee that you will
authenticate by password, just that you are willing to do it if the
server agrees. The server makes the decision and might still
authenticate you by another method.</p>



If a client wants to <a name="INDEX-1229" />require an authentication technique,
it must tell the server that one, and only one, technique is
acceptable. To do this, the client must deselect every other
authentication technique. For example, to force password
authentication in SSH1 or OpenSSH:</p>



<blockquote><pre class="code"># SSH1, OpenSSH
# This guarantees password authentication, if the server supports it.
PasswordAuthentication  yes
RSAAuthentication       no
RhostsRSAAuthentication no
RhostsAuthentication    no
KerberosAuthentication  no
# <i class="lineannotation">... Add any other authentication methods, with value "no"</i></pre></blockquote>



If the server doesn't support password authentication, however,
this connection attempt will fail.</p>



SSH2 has a better system: the
<tt class="literal">AllowedAuthentications</tt><a name="INDEX-1230" />
keyword, which has the same syntax and meaning as the server keyword
of the same name: [<a href="ch05_05.html#ch05-46136">Section 5.5.1, "Authentication"</a>]</p>



<blockquote><pre class="code"># SSH2 only
AllowedAuthentications password</pre></blockquote>
</div>





<a name="ch07-40-fm2xml" /><div class="sect3">
<h3 class="sect3">7.4.10.3. Detecting successful authentication</h3>



SSH2 provides two keywords for reporting whether authentication is
successful:
<tt class="literal">AuthenticationSuccessMsg</tt><a name="INDEX-1231" />
and
<tt class="literal">AuthenticationNotify</tt><a name="INDEX-1232" />.
Each of these causes SSH2 clients to print a message after attempting
authentication.</p>



<tt class="literal">AuthenticationSuccessMsg</tt> controls the appearance
of the message "Authentication successful" after
authentication, which is printed on standard error. Values may be
<tt class="literal">yes</tt> (the default, to display the message) or
<tt class="literal">no</tt>:</p>



<blockquote><pre class="code">$ ssh2 server.example.com
Authentication successful.
Last login: Sat Jun 24 2000 14:53:28 -0400
...
$ ssh2 -p221 -o 'AuthenticationSuccessMsg no' server.example.com
Last login: Sat Jun 24 2000 14:53:28 -0400
...</pre></blockquote>



<tt class="literal">AuthenticationNotify</tt>, an undocumented keyword,
causes <tt class="command">ssh2</tt> to print a different message, this
time on standard output. If the authentication is successful, the
message is "AUTHENTICATED YES", otherwise it's
"AUTHENTICATED NO". Values may be <tt class="literal">yes</tt>
(print the message) or <tt class="literal">no</tt> (the default):</p>



<blockquote><pre class="code">$ ssh2 -q -o 'AuthenticationNotify yes' server.example.com
AUTHENTICATED YES
Last login: Sat Jun 24 2000 14:53:35 -0400
...</pre></blockquote>



The
<a name="INDEX-1233" />behavior of these two
keywords differs in the following ways:</p>



<ul><li><tt class="literal">AuthenticationSuccessMsg</tt> writes to stderr;
<tt class="literal">AuthenticationNotify</tt> writes to stdout.</p></li><li>The <span class="option">-q</span> command-line option [<a href="ch07_04.html#ch07-20984">Section 7.4.15, "Logging and Debugging"</a>] silences
<tt class="literal">AuthenticationSuccessMsg</tt> but not
<tt class="literal">AuthenticationNotify</tt>. This makes
<tt class="literal">AuthenticationNotify</tt> better for scripting (for
example, to find out if an authentication can succeed or not). Notice
that <tt class="command">exit</tt> is used as a remote command so the shell
terminates immediately:</p>
<blockquote><pre class="code">#!/bin/csh
# Get the AUTHENTICATION line
set line = `ssh2 -q -o 'AuthenticationNotify yes' server.example.com exit`
# Capture the second word
set result = `echo $line | awk '{print $2}'`
if ( $result == "YES" ) then
  ...</pre></blockquote>


In fact, <tt class="literal">AuthenticationNotify</tt> is used precisely in
this manner by <tt class="command">scp2</tt> and <tt class="command">sftp</tt>,
then these programs run <tt class="command">ssh2</tt> in the background to
connect to the remote host for file transfers. They wait for the
appearance of the "AUTHENTICATED YES" message to know
that the connection was successful, and they can now start speaking
to the <tt class="command">sftp-server</tt>.</p></li></ul>
<tt class="literal">AuthenticationSuccessMsg</tt> provides an additional
safety feature: a guarantee that authentication has occurred. Suppose
you invoke <tt class="command">ssh2</tt> and are prompted for your
passphrase:</p>



<blockquote><pre class="code">$ ssh2 server.example.com
Passphrase for key "mykey": ********</pre></blockquote>



You then see, to your surprise, a second passphrase prompt:</p>



<blockquote><pre class="code">Passphrase for key "mykey":</pre></blockquote>



You might conclude that you mistyped your passphrase the first time
and type it again. But what if the second prompt came not from your
<tt class="command">ssh2</tt> client, but from the server, which has been
hacked by a evil intruder? Your passphrase has just been stolen! To
counteract this potential threat, <tt class="command">ssh2</tt> prints
"Authentication successful" after authentication, so the
previous session actually looks like this:</p>



<blockquote><pre class="code">$ ssh2 server.example.com
Passphrase for key "mykey": ********
Authentication successful.
Passphrase for key "mykey":</pre></blockquote>



The second passphrase prompt is now revealed as a fraud.</p>
</div>
</div>








<a name="ch07-17634" /><div class="sect2">
<h3 class="sect2">7.4.11. Data Compression</h3>



<a name="INDEX-1234" /><a name="INDEX-1235" />SSH connections may be compressed.
That is, data sent over an SSH connection may be compressed
automatically<span class="option"> </span>before it is encrypted and sent, and
automatically uncompressed after it is received and decrypted. If
you're running SSH software on fast, modern processors,
compression is generally a win. In an informal test between two Sun
SPARCstation 10 workstations connected by Ethernet, we transmitted 12
MB of text from server to client over compressed and uncompressed SSH
connections. With compression enabled at an appropriate level
(explained later), the transmission time was halved.</p>



To enable compression for a single session, use command-line options.
Unfortunately, the implementations have incompatible syntax. For SSH1
and OpenSSH, compression is disabled by default, and the
<span class="option">-C</span> command-line option turns it on:</p>



<blockquote><pre class="code"># SSH1, OpenSSH: turn compression ON
$ ssh1 -C server.example.com
$ scp1 -C myfile server.example.com:</pre></blockquote>



For SSH2, however, <span class="option">-C </span>means the opposite, turning
compression off:</p>



<blockquote><pre class="code"># SSH2 only: turn compression OFF
$ ssh2 -C server.example.com</pre></blockquote>



and <em class="emphasis">+C</em> turns it on:</p>



<blockquote><pre class="code"># SSH2 only: turn compression ON
$ ssh2 +C server.example.com</pre></blockquote>



(There is no compression option for <tt class="command">scp2</tt>.) To
enable or disable compression for all sessions, use the
<tt class="literal">Compression</tt><a name="INDEX-1236" />
keyword, given a value of <tt class="literal">yes</tt> or
<tt class="literal">no</tt> (the default):</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
Compression yes</pre></blockquote>



SSH1 and OpenSSH may also set an integer <tt class="command">compression
level</tt> to indicate how much the data should be compressed.
Higher levels mean better compression but slower performance. Levels
may be from
to 9 inclusive, and the default level is 6.<a href="#FOOTNOTE-104">[104]</a> The
<tt class="literal">CompressionLevel</tt><a name="INDEX-1237" />
keyword modifies the level:</p><blockquote class="footnote">


<a name="FOOTNOTE-104" />[104]SSH's compression functionality comes from GNU Zip,
a.k.a., <tt class="command">gzip</tt>, a compression utility popular in the
Unix world. The nine <tt class="literal">CompressionLevel</tt> values
correspond to the nine methods supported by
<tt class="command">gzip</tt>.</p>


</blockquote>



<blockquote><pre class="code"># SSH1, OpenSSH
CompressionLevel 2</pre></blockquote>



Changing the <tt class="literal">CompressionLevel</tt> can have a drastic
effect on performance. Our earlier 12-MB test was run with the
default compression level, 6, and took 42 seconds. With compression
at various levels, the time ranged from 25 seconds to nearly two
minutes (see <a href="ch07_04.html#ch07-60362">Table 7-2</a>). With fast processors and
network connections, <tt class="literal">CompressionLevel</tt>
<tt class="literal">1</tt> seems an obvious win. Experiment with
<tt class="literal">CompressionLevel</tt> to see which value yields the
best performance for your setup.</p>



<a name="ch07-60362" /><h4 class="objtitle">Table 7-2. Effect of Compression and CompressionLevel </h4><table border="1">






<tr>
<th>
Level</p></th>
<th>
Bytes Sent</p></th>
<th>
Time Spent (sec.)</p></th>
<th>
Size Reduced (%)</p></th>
<th>
Time Reduced (%)</p></th>
</tr>






<tr>
<td>
None</p></td>
<td>
12112880</p></td>
<td>
55</p></td>
<td>
0</p></td>
<td>
0</p></td>
</tr>


<tr>
<td>
1</p></td>
<td>
 2116435</p></td>
<td>
25</p></td>
<td>
82.5</p></td>
<td>
55</p></td>
</tr>


<tr>
<td>
2</p></td>
<td>
 2091292</p></td>
<td>
25</p></td>
<td>
82.5</p></td>
<td>
55</p></td>
</tr>


<tr>
<td>
3</p></td>
<td>
 2079467</p></td>
<td>
27</p></td>
<td>
82.8</p></td>
<td>
51</p></td>
</tr>


<tr>
<td>
4</p></td>
<td>
 1881366</p></td>
<td>
33</p></td>
<td>
84.4</p></td>
<td>
40</p></td>
</tr>


<tr>
<td>
5</p></td>
<td>
 1833850</p></td>
<td>
36</p></td>
<td>
84.8</p></td>
<td>
35</p></td>
</tr>


<tr>
<td>
6</p></td>
<td>
 1824180</p></td>
<td>
42</p></td>
<td>
84.9</p></td>
<td>
24</p></td>
</tr>


<tr>
<td>
7</p></td>
<td>
 1785725</p></td>
<td>
48</p></td>
<td>
85.2</p></td>
<td>
13</p></td>
</tr>


<tr>
<td>
8</p></td>
<td>
 1756048</p></td>
<td>
102</p></td>
<td>
85.5</p></td>
<td>
-46</p></td>
</tr>


<tr>
<td>
9</p></td>
<td>
 1755636</p></td>
<td>
118</p></td>
<td>
85.5</p></td>
<td>
-53</p></td>
</tr>



</table><p>
</div>








<a name="ch07-41-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.12. Program Locations</h3>



The auxiliary program
<tt class="command">ssh-signer2</tt><a name="INDEX-1238" />
is normally located in SSH2's installation directory, along
with the other SSH2 binaries. [<a href="ch03_05.html#ch03-52465">Section 3.5.2.3, "Setuid client"</a>] You can
change this location with the undocumented keyword
<tt class="literal">SshSignerPath</tt><a name="INDEX-1239" />:</p>



<blockquote><pre class="code"># SSH2 only
SshSignerPath /usr/alternative/bin/ssh-signer2</pre></blockquote>



If you use this keyword, be sure to set it to the fully qualified
path of the program. If you use a relative path, hostbased
authentication works only for users who have
<tt class="command">ssh-signer2</tt> in their search path, and
<em class="emphasis">cron</em> jobs fail without
<tt class="command">ssh-signer2</tt> in their path.</p>
</div>








<a name="ch07-42-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.13. Subsystems</h3>



<a name="INDEX-1240" />Subsystems
are predefined commands supported by an SSH2 server. [<a href="ch05_07.html#ch05-86335">Section 5.7, "Subsystems"</a>] Each installed server can implement different
subsystems, so check with the system administrator of the server
machine for a list.<a href="#FOOTNOTE-105">[105]</a></p><blockquote class="footnote">


<a name="FOOTNOTE-105" />[105]Or examine the server
machine's configuration file <em class="filename">/etc/ssh2/sshd2_config
</em>yourself for lines beginning with
<tt class="command">subsystem-</tt>.</p>


</blockquote>



The <span class="option">-s</span> option of <tt class="command">ssh2</tt>,
undocumented at press time, invokes a subsystem on a remote machine.
For example, if the SSH2 server running on
<em class="filename">server.example.com</em> has a "backups"
subsystem defined, you run it as:</p>



<blockquote><pre class="code">$ ssh2 -s backups server.example.com</pre></blockquote>
</div>








<a name="ch07-74869" /><div class="sect2">
<h3 class="sect2">7.4.14. SSH1/SSH2 Compatibility</h3>



<a name="INDEX-1241" />SSH2 has a few keywords relating to SSH1
compatibility. If compatibility is enabled, when
<tt class="command">ssh2</tt> is asked to connect to an SSH-1 server, it
invokes <tt class="command">ssh1</tt> (assuming it is available).</p>



The keyword
<tt class="literal">Ssh1Compatibility</tt><a name="INDEX-1242" />
turns on SSH1 compatibility, given the value <tt class="literal">yes</tt>
or <tt class="literal">no</tt>. The default is <tt class="literal">yes</tt> if
compatibility is compiled in; otherwise it is <tt class="literal">no</tt>:</p>



<blockquote><pre class="code"># SSH2 only
Ssh1Compatibility yes</pre></blockquote>



The keyword
<tt class="literal">Ssh1Path</tt><a name="INDEX-1243" />
locates the executable for <tt class="command">ssh1</tt>, which by default
is set during compile-time configuration:</p>



<blockquote><pre class="code"># SSH2 only
Ssh1Path /usr/local/bin/ssh1</pre></blockquote>



If you want SSH2 <a name="INDEX-1244" />agents to store and retrieve SSH1
keys, turn on agent compatibility with the keyword
<tt class="literal">Ssh1AgentCompatibility</tt><a name="INDEX-1245" />: [<a href="ch06_03.html#ch06-69275">Section 6.3.2.4, "SSH-1 and SSH-2 agent compatibility"</a>]</p>



<blockquote><pre class="code"># SSH2 only
Ssh1AgentCompatibility yes</pre></blockquote>



Finally,
<tt class="command">scp2</tt><a name="INDEX-1246" /> invokes <tt class="command">scp1</tt> if
the <span class="option">-1</span> command-line option is present:</p>



<blockquote><pre class="code"># SSH2 only
scp2 -1 myfile server.example.com:</pre></blockquote>



In this case, <tt class="command">scp2
</tt><span class="option">-</span><tt class="command">1</tt> simply invokes
<tt class="command">scp1</tt>, passing along all its arguments (except for
the <span class="option">-1</span> of course). We don't see much point to
this option: if <tt class="command">scp1</tt> is available, why not invoke
it directly? But the option is there if you need it.</p>
</div>








<a name="ch07-20984" /><div class="sect2">
<h3 class="sect2">7.4.15. Logging and Debugging</h3>



<a name="INDEX-1247" /><a name="INDEX-1248" />Earlier
in the chapter, we introduced the <span class="option">-v</span> command-line
option which causes SSH clients to print debugging messages.
Verbose mode works for <tt class="command">ssh</tt> and <tt class="command">scp </tt>:<a name="INDEX-1249" /></p>



<blockquote><pre class="code"># SSH1, OpenSSH
$ ssh -v server.example.com
SSH Version 1.2.27 [sparc-sun-solaris2.5.1], protocol version 1.5.
client: Connecting to server.example.com [128.9.176.249] port 22.
client: Connection established.
...</pre></blockquote>



Verbose mode can also be turned on for SSH2 with the (surprise!)
<tt class="literal">VerboseMode</tt><a name="INDEX-1250" />
keyword:</p>



<blockquote><pre class="code"># SSH2 only
VerboseMode yes</pre></blockquote>



If you ever encounter problems or strange behavior from SSH, your
first instinct should be to turn on verbose mode.</p>



SSH2 has multiple
<a name="INDEX-1251" />levels of debug messages; verbose mode
corresponds to level 2. You can specify greater or less debugging
with the <span class="option">-d</span> command-line option, followed by an
integer from
to 99:</p>



<blockquote><pre class="code">$ ssh2 -d0      <i class="lineannotation">No debugging messages</i>

$ ssh2 -d1      <i class="lineannotation">Just a little
debugging</i>
$ ssh2 -d2      <i class="lineannotation">Same as-v</i>
$ ssh2 -d3      <i class="lineannotation">A little more detailed</i>
$ ssh2 -d#      <i class="lineannotation">And so on...</i></pre></blockquote>



The analogous feature in OpenSSH is the
<tt class="literal">LogLevel</tt><a name="INDEX-1252" />
directive, which takes one of six levels as an argument:
<tt class="literal">QUIET</tt>, <tt class="literal">FATAL</tt>,
<tt class="literal">ERROR</tt>, <tt class="literal">INFO</tt>,
<tt class="literal">VERBOSE</tt>, and <tt class="literal">DEBUG</tt> (in order of
increasing verbosity). So for example:</p>



<blockquote><pre class="code"># OpenSSH
$ ssh -o LogLevel=DEBUG</pre></blockquote>



is equivalent to <tt class="command">ssh
</tt><span class="option">-v</span>.</p>



The <span class="option">-d</span> option may also use the same module-based
syntax as for server debugging: [<a href="ch05_08.html#ch05-36355">Section 5.8.2.2, "SSH2 Debug mode (module-based)"</a>]</p>



<blockquote><pre class="code">$ ssh2 -d Ssh2AuthPasswdServer=2 server.example.com</pre></blockquote>



<tt class="command">scp2</tt><a name="INDEX-1253" />
also supports this level of debugging, but the option is
<span class="option">-D</span> instead of <span class="option">-d</span> since <tt class="command">scp
</tt><span class="option">-d</span> is already used to
mean something else:</p>



<blockquote><pre class="code">$ scp2 -D Ssh2AuthPasswdServer=2 myfile server.example.com</pre></blockquote>



To disable all debug messages, use <span class="option">-q</span>:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -q server.example.com

# SSH2 only
$ scp2 -q myfile server.example.com:</pre></blockquote>



or the <tt class="literal">QuietMode</tt> keyword:</p>



<blockquote><pre class="code"># SSH2 only
QuietMode yes</pre></blockquote>



Finally, to print the program version number, use <span class="option">-V</span>:</p>



<blockquote><pre class="code"># SSH1, SSH2, OpenSSH
$ ssh -V

# SSH2 only
$ scp2 -V</pre></blockquote>
</div>








<a name="ch07-43-fm2xml" /><div class="sect2">
<h3 class="sect2">7.4.16. Random Seeds</h3>



<a name="INDEX-1254" />SSH2 lets
you change the location of your random seed file, which is
<em class="filename">~/.ssh2/random_seed</em> by default: [<a href="ch05_04.html#ch05-92636">Section 5.4.1.2, "Random seed file"</a>]</p>



<blockquote><pre class="code"># SSH2 only
RandomSeedFile /u/smith/.ssh2/new_seed</pre></blockquote>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_03.html"><img alt="Previous" border="0" src="../gifs/txtpreva.gif" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img alt="Home" border="0" src="../gifs/txthome.gif" /></a></td><td align="right" valign="top" width="228"><a href="ch07_05.html"><img alt="Next" border="0" src="../gifs/txtnexta.gif" /></a></td></tr><tr><td align="left" valign="top" width="228">7.3. Introduction to Verbose Mode</td><td align="center" valign="top" width="228"><a href="index/index.html"><img alt="Book Index" border="0" src="../gifs/index.gif" /></a></td><td align="right" valign="top" width="228">7.5. Secure Copy with scp</td></tr></table><div>
<hr width="684" align="left" />

<img alt="Library Navigation Links" border="0" src="../gifs/navbar.gif" usemap="#library-map" />
<p><font size="-1"><a href="copyrght.html">Copyright &copy; 2002</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map"><area shape="rect" coords="1,0,84,90" href="../index.html" /><area shape="rect" coords="86,-7,176,90" href="index.html" /><area shape="rect" coords="178,0,265,101" href="../tcp/index.html" /><area shape="rect" coords="266,0,333,90" href="../nfs/index.html" /><area shape="rect" coords="334,-1,429,93" href="../snmp/index.html" /><area shape="rect" coords="431,0,529,116" href="../tshoot/index.html" /><area shape="rect" coords="534,0,594,104" href="../dns/index.html" /><area shape="rect" coords="595,1,704,108" href="../fire/index-2.html" /></map>

</body>
<!-- Mirrored from nnc3.com/mags/Networking2/ssh/ch07_04.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2017 17:56:10 GMT -->
</html>